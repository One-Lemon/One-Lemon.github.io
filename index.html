<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="JavaScript,Vue,React,小程序,前端,Node">
  
  
    <meta name="description" content="静待一树花开，盼你叶落归来。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    oneQiu Blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="oneQiu Blog" type="application/atom+xml">
</head>


<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">oneQiu Blog</a></h1>
      <p>静待一树花开，盼你叶落归来。</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="oneQiu Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-小程序坑" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9D%91/">小程序奇葩坑点</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9D%91/" class="article-date">
  <time datetime="2020-05-16T04:40:28.307Z" itemprop="datePublished">2020-05-16</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="小程序坑点总结"><a href="#小程序坑点总结" class="headerlink" title="小程序坑点总结"></a>小程序坑点总结</h1><h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><blockquote>
<p>可怜的我在产品的逼迫下，要在PC微信和PC企业微信都能完美运行小程序。四月份的时候，PC微信有了小程序面板，然后我就开始了写bug之路。</p>
</blockquote>
<h2 id="PC微信小程序没有首页按钮"><a href="#PC微信小程序没有首页按钮" class="headerlink" title="PC微信小程序没有首页按钮"></a>PC微信小程序没有首页按钮</h2><blockquote>
<p>小程序在使用的时候，会根据判断路由信息是否为空，如果为空，会在导航栏自动生成一个首页的按钮。在PC微信中，小程序并不会去根据路由信息判断，</p>
</blockquote>
<p>触发场景：</p>
<ul>
<li>当你使用<code>wx.reLaunch</code>或者<code>wx.redirectTo</code>使得当前路由为空的时候，并不会出现回到首页的按钮。</li>
<li>直接跳到非首页路由页面</li>
</ul>
<p>解决方法：</p>
<ul>
<li>非首页页面添加侧边快捷操作按钮，这个可以作为一个组件，不过相对比较麻烦，而且会遮挡页面内容</li>
<li>使用自定义导航栏，好用，但是部分场景会引发的Bug就比较扎心了，自定义导航栏另外介绍。</li>
</ul>
<h2 id="上传图片无效"><a href="#上传图片无效" class="headerlink" title="上传图片无效"></a>上传图片无效</h2><blockquote>
<p>小程序上传文件我们使用<code>wx.uploadFile</code>，然后我在官方文档看到这么一句话。</p>
<p> 将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 <code>content-type</code> 为 <code>multipart/form-data</code>。 </p>
<p>PS：正是因为这一句话，引发了我这次寻Bug之旅，企业微信联系了小程序官方问这个问题，他们表示没复现出来。</p>
</blockquote>
<p>触发场景：</p>
<ul>
<li><code>wx.uploadFile</code>中添加了<code>content-type: multipart/form-data</code></li>
<li>在PC微信或者PC企业微信中运行小程序进行上传图片</li>
</ul>
<p>解决方法：</p>
<ul>
<li>去掉<code>content-type: multipart/form-data</code></li>
</ul>
<h2 id="PC端运行小程序"><a href="#PC端运行小程序" class="headerlink" title="PC端运行小程序"></a>PC端运行小程序</h2><p>企业微信</p>
<ul>
<li>企业微信暂只支持运行正式版小程序，不能唤起体验版，包括分享体验版也是无法使用</li>
</ul>
<p>微信</p>
<ul>
<li>可以使用所有版本的小程序</li>
</ul>
<p>Tips：如果你要在PC微信运行开发版，通常有这几种方法</p>
<ul>
<li>截图二维码发在微信上，微信现在可以扫描图片二维码</li>
<li>在微信开发者工具中打开通用设置 -&gt; 启动PC端自动预览</li>
</ul>
<h2 id="微信开发者工具反复横跳"><a href="#微信开发者工具反复横跳" class="headerlink" title="微信开发者工具反复横跳"></a>微信开发者工具反复横跳</h2><blockquote>
<p>某些场景下我们可能需要手动操作返回，比如使用<code>wx.navigateBack</code>，然后在使用小程序自带的返回键会在两个页面来回跳动</p>
</blockquote>
<p>触发场景：</p>
<ul>
<li>部分页面自定义导航栏</li>
<li>仅仅出现在微信开发者工具上面</li>
</ul>
<p>解决方法：</p>
<ul>
<li>无视。。。因为，实际用起来并不会这样，只是在开发者工具上会这样，很奇怪</li>
<li>全部使用自定义导航栏</li>
</ul>
<h2 id="PC小程序不支持chooseMessageFile"><a href="#PC小程序不支持chooseMessageFile" class="headerlink" title="PC小程序不支持chooseMessageFile"></a>PC小程序不支持<code>chooseMessageFile</code></h2><blockquote>
<p>现在的小程序可以通过<code>wx.chooseMessageFile</code>去选择图片以外的各种格式的文件。辣么，问题来了，在PC上会提示<code>chooseMessageFile:fail:not supported</code>。在<code>Ststem</code>中你会发现版本号明明比这个<code>API</code>高呀。但是还是会这样，企业微信上联系了小程序助手，emm，暂时无解。</p>
</blockquote>
<h2 id="页面底部的input框在输入时会把自定义导航栏挤掉"><a href="#页面底部的input框在输入时会把自定义导航栏挤掉" class="headerlink" title="页面底部的input框在输入时会把自定义导航栏挤掉"></a>页面底部的<code>input</code>框在输入时会把自定义导航栏挤掉</h2><blockquote>
<p>自定义导航栏也算页面内容，所以也是会被强制位移</p>
</blockquote>
<p>触发场景：</p>
<ul>
<li>自定义导航栏 &amp;&amp; 页面底部有输入框</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>尽量避免在页面底部出现输入框</p>
</li>
<li><p>监听文本框<code>bindblur   bindfocus</code>事件，在聚焦时候动态改变页面的<code>padding-bottom</code></p>
<p> <code>event.detail = { value, height }，height 为键盘高度</code></p>
</li>
<li><p>设置 <code>input</code> 的 <code>adjust-position</code> 为 <code>false</code>，不自动上推，用 <code>wx.pageScrollTo</code> 来自定义上推行为 </p>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9D%91/" data-id="cka95725f0000h0ul058x53ma" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-思考时间" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/31/%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4/">思考时间</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2019/05/31/%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4/" class="article-date">
  <time datetime="2019-05-31T02:04:32.000Z" itemprop="datePublished">2019-05-31</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    
                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2019/05/31/%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4/" data-id="cka95470h000ws0ul1zzw46nv" class="article-share-link">
                                            分享
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-bug" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/05/29/bug/">bug</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2019/05/29/bug/" class="article-date">
  <time datetime="2019-05-29T03:26:22.000Z" itemprop="datePublished">2019-05-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="在-router-link标签上绑定事件"><a href="#在-router-link标签上绑定事件" class="headerlink" title="在 router-link标签上绑定事件"></a>在 <code>router-link</code>标签上绑定事件</h3><blockquote>
<p>添加修饰符 <code>.native</code></p>
</blockquote>
<h3 id="使用-kepp-alive-标签使用-include控制组件缓存"><a href="#使用-kepp-alive-标签使用-include控制组件缓存" class="headerlink" title="使用 kepp-alive 标签使用 include控制组件缓存"></a>使用 <code>kepp-alive</code> 标签使用 <code>include</code>控制组件缓存</h3><blockquote>
<p>使用多组时候，使用逗号隔开，但是不能有空格</p>
</blockquote>
<h3 id="滚动条不同组件复用"><a href="#滚动条不同组件复用" class="headerlink" title="滚动条不同组件复用"></a>滚动条不同组件复用</h3><blockquote>
</blockquote>
<h3 id="JS-数组排序-a-z"><a href="#JS-数组排序-a-z" class="headerlink" title="JS 数组排序 a-z"></a>JS 数组排序 a-z</h3><p>这里有一组字符串的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"M"</span>,<span class="string">"U"</span>,<span class="string">"Z"</span>,<span class="string">"H"</span>,<span class="string">"B"</span>,<span class="string">"K"</span>,<span class="string">"S"</span>,<span class="string">"N"</span>,<span class="string">"T"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>,<span class="string">"J"</span>,<span class="string">"I"</span>,<span class="string">"T"</span>,<span class="string">"I"</span>,<span class="string">"R"</span>,<span class="string">"P"</span>,<span class="string">"R"</span>,<span class="string">"C"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"C"</span>,<span class="string">"P"</span>,<span class="string">"M"</span>,<span class="string">"D"</span>,<span class="string">"H"</span>,<span class="string">"B"</span>,<span class="string">"N"</span>,<span class="string">"G"</span>,<span class="string">"B"</span>,<span class="string">"A"</span>];</span><br></pre></td></tr></table></figure>

<p>对其进行排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;<span class="keyword">return</span> v1&gt;v2&#125;);</span><br><span class="line">/[<span class="string">"P"</span>, <span class="string">"A"</span>, <span class="string">"R"</span>, <span class="string">"M"</span>, <span class="string">"B"</span>, <span class="string">"K"</span>, <span class="string">"B"</span>, <span class="string">"G"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"J"</span>, <span class="string">"I"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"D"</span>, <span class="string">"M"</span>, <span class="string">"H"</span>, <span class="string">"C"</span>, <span class="string">"C"</span>, <span class="string">"C"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"N"</span>, <span class="string">"N"</span>, <span class="string">"P"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"Z"</span>]</span><br></pre></td></tr></table></figure>

<p>这个结果是我们不想要的，但是按道理没错误鸭。</p>
<p>解决方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1&gt;v2?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新"><a href="#vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新" class="headerlink" title="vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新"></a>vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新</h4><p><strong>Vue 封装组件，然后传参，引用类型，出现了联动问题</strong></p>
<blockquote>
<ol>
<li>传值时候使用 concat 让他成为一个新数组</li>
<li>扩展运算符</li>
<li>return</li>
</ol>
</blockquote>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2019/05/29/bug/" data-id="cka95470i000xs0ulgsml65m8" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bug/" rel="tag">bug</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Redux" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/24/Redux/">Redux</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/09/24/Redux/" class="article-date">
  <time datetime="2018-09-24T02:45:36.000Z" itemprop="datePublished">2018-09-24</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li>引入 redux <code>import redux from &#39;redux&#39;</code></li>
<li>创建 strore 实例对象 <code>const store = redux.createStore((state, action) =&gt; { return xxx })</code> 这个函数默认进来一次，可以做为仓库的初始化工作。</li>
<li>暴露 store <code>export default store</code></li>
</ol>
<ul>
<li>获取仓库中的数据 <code>store.getState().xxx</code></li>
</ul>
<h2 id="修改仓库的数据"><a href="#修改仓库的数据" class="headerlink" title="修改仓库的数据"></a>修改仓库的数据</h2><p><code>store.dispatch(action)</code> 派发一个动作</p>
<h2 id="组件得到-store-改变之后修改自身数据"><a href="#组件得到-store-改变之后修改自身数据" class="headerlink" title="组件得到 store 改变之后修改自身数据"></a>组件得到 store 改变之后修改自身数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe()</span><br></pre></td></tr></table></figure>

<p>Reducer 返回一个新的 state，真正修改的是 state</p>
<h2 id="action-是什么？"><a href="#action-是什么？" class="headerlink" title="action 是什么？"></a>action 是什么？</h2><blockquote>
<p>action 就是一个包含 type 和 value 的对象</p>
</blockquote>
<ul>
<li><code>return Object.assign({}, state, { name: action.value })</code></li>
<li><code>return { ...state, name: action.value }</code></li>
<li><code>let newState = {...state};return newState</code></li>
<li><code>let newState = JSON.parse(JSON.stringify(state))</code></li>
</ul>
<h2 id="action-创建函数"><a href="#action-创建函数" class="headerlink" title="action 创建函数"></a>action 创建函数</h2><h2 id="reducer-拆分"><a href="#reducer-拆分" class="headerlink" title="reducer 拆分"></a>reducer 拆分</h2><h2 id="ANTD"><a href="#ANTD" class="headerlink" title="ANTD"></a>ANTD</h2><h2 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h2><h3 id="redux-ogger"><a href="#redux-ogger" class="headerlink" title="redux-ogger"></a>redux-ogger</h3><h3 id="redyx-thunk"><a href="#redyx-thunk" class="headerlink" title="redyx-thunk"></a>redyx-thunk</h3><blockquote>
<p>这个中间件的使用，让我们 <code>store.dispatch</code> 能支持接收到函数，以前只支持对象。</p>
<p>闭包</p>
<p>dom 对象  ie 低版本 内存泄漏</p>
</blockquote>
<h3 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h3><h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="UI-组件与容器组件"><a href="#UI-组件与容器组件" class="headerlink" title="UI 组件与容器组件"></a>UI 组件与容器组件</h3><h4 id="UI-组件（展示组件）"><a href="#UI-组件（展示组件）" class="headerlink" title="UI 组件（展示组件）"></a>UI 组件（展示组件）</h4><blockquote>
<p>一般来说 UI 组件，只负责 UI 的渲染，不负责数据的情况，它不需要 state 数据，它上面的数据全是容器组件来通过 props 传递下来的。所以一般我们可以将 UI 组件写成 function 组件。</p>
</blockquote>
<h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><blockquote>
<p>它麦处理数据，负责跟 redux 打交道。</p>
</blockquote>
<hr>
<ul>
<li><code>connect(mapStateToprops, mapDispatchToprops)(UI 组件)</code></li>
<li>Provider 组件</li>
</ul>
<ol>
<li><code>yarn add react-redux</code></li>
<li>项目入口，使用 Provider 组件将 store 的数据 context 下去。</li>
<li>实现 UI 组件，由 connect 帮我们去创建容器组件。</li>
</ol>
<h2 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h2><ul>
<li>react-router                                Link</li>
<li>react-router-dom（推荐） NavLink    高亮效果</li>
</ul>
<h3 id="提供的路由相关组件"><a href="#提供的路由相关组件" class="headerlink" title="提供的路由相关组件"></a>提供的路由相关组件</h3><ul>
<li><p>路由组件（全局只能有一个）</p>
<ul>
<li><p>BrowserRouter        history模式</p>
</li>
<li><p>HashRouter                hash模式</p>
</li>
</ul>
<p>表现形式不同    原理不同</p>
</li>
<li><p>单个的路由规则组件</p>
<ul>
<li>Route</li>
</ul>
</li>
<li><p>全局路由</p>
<ul>
<li>Router</li>
</ul>
</li>
<li><p>导航组件</p>
<ul>
<li>Link</li>
<li>NavLink</li>
</ul>
</li>
<li><p>只匹配一条规则</p>
<ul>
<li>Switch    从上往下渲染，只匹配第一条</li>
</ul>
</li>
<li><p>Redirect</p>
</li>
<li><p>widthRouter    方法    高阶组件</p>
</li>
</ul>
<h3 id="路由界面自动接收到的三个-prop，路由页面组件中的其他组件是获取不到的。"><a href="#路由界面自动接收到的三个-prop，路由页面组件中的其他组件是获取不到的。" class="headerlink" title="路由界面自动接收到的三个 prop，路由页面组件中的其他组件是获取不到的。"></a>路由界面自动接收到的三个 prop，路由页面组件中的其他组件是获取不到的。</h3><ul>
<li>history<ul>
<li><code>push()</code></li>
<li><code>replace()</code></li>
<li><code>go()</code></li>
<li><code>goBack()</code></li>
<li><code>goForward()</code></li>
</ul>
</li>
<li>location<ul>
<li>search  query 的参数</li>
</ul>
</li>
<li>match<ul>
<li>params 动态路由</li>
</ul>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/09/24/Redux/" data-id="cka9546zo0001s0ul8cgg608r" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-React-生命周期" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/23/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">React 生命周期</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/09/23/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2018-09-23T07:08:23.000Z" itemprop="datePublished">2018-09-23</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h1><blockquote>
<p>在 React 中开始创建到销毁有着一系列的生命周期，对此，我表达一下自己对 React 生命周期的理解哈。</p>
</blockquote>
<p>首先贴一张 React 官方的生命周期图</p>
<p><a href="/medias/images/React-live.png">React-生命周期</a></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol>
<li><p><code>constructor(props)</code> 构造函数</p>
<ul>
<li><p>在 React 创建时，调用一次 <code>constructor</code> 。</p>
</li>
<li><p>参数 props，获取父组件传入的数据。</p>
</li>
<li><p>能做些什么？</p>
<ol>
<li><code>super(props)</code> 可以理解为修改当前 this 指向，如果你要在后面正确的使用当前的 this，那么就一定需要。</li>
<li>统一修改事件方法的 this 指向（事件方法修改 this 指向的方法之一），例：<code>this.onClick = this.onClick.bind(this)</code>。</li>
<li>初始化 state，例：<code>this.setState = { name: &#39;cxk&#39; }</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>static getDerivedStateFromProps(nextProps, nextState)</code> 静态方法 从 props 派生 state</p>
<ul>
<li><p>props | state 变化前，对其进行操作。</p>
</li>
<li><p>参数 <code>nextProps, nextState</code> 获取变化之后的数据。</p>
</li>
<li><p>需要 <code>return</code> 返回值，返回 state，如果不需要修改 state 值，那么直接 <code>return null</code>。</p>
</li>
<li><p>在此方法里面不能获取到 <code>this</code>。</p>
</li>
<li><p>可以认为此方法替代了 <code>componentWillMount</code>。</p>
</li>
</ul>
</li>
<li><p><code>render()</code> 渲染 DOM</p>
</li>
<li><p><code>componentDidMount(prevProps, prevState)</code> 组件挂载完成</p>
<ul>
<li>参数 <code>prevProps,prevState</code> 修改之前的参数。</li>
<li>可以获得当前组件的 <code>this</code>，所以可以使用 <code>setState</code>，它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</li>
<li>这里适合发起网络请求去获取数据。</li>
</ul>
</li>
</ol>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol>
<li><code>static getDerivedStateFromProps(nextProps, nextState)</code> </li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code> 组件是否更新<ul>
<li>需要 <code>return</code> 返回值，返回波尔值，如果返回 <code>true</code> 则正常进行更新，返回 <code>false</code> 中断当前更新。</li>
<li>能获取到 <code>this</code>。</li>
</ul>
</li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code> 在组件更新前一刻<ul>
<li>能够获取 <code>this</code>。</li>
<li>需要一个 <code>return</code> 返回值，这个数据将会在 <code>componentDidUpdate</code> 中以第三个参数 <code>snapshot</code> 所获取到。</li>
</ul>
</li>
<li><code>componentDidUpdate(prevProps, prevState, snapshot)</code> 组件更新完成<ul>
<li>能获取到 <code>this</code>。</li>
<li>第三个参数 <code>snapshot</code> 是上一个生命周期函数的 <code>return</code> 值。</li>
</ul>
</li>
</ol>
<p><strong>注：在更新的生命周期函数里面要警惕使用 <code>this.setState</code>，如果使用一定要注意出口，否则会造成死循环。</strong></p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul>
<li><code>componentWillUnmont()</code> 组件卸载前<ul>
<li>通常都是在这里面清除监听之类，以免造成对其他组件的影响。</li>
</ul>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/09/23/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" data-id="cka9546zh0000s0ul54lpeeul" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag">生命周期</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-React基础" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/08/17/React%E5%9F%BA%E7%A1%80/">React基础</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/08/17/React%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2018-08-17T00:57:44.000Z" itemprop="datePublished">2018-08-17</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><blockquote>
<p>React 是 Fackbook 当初不满意市面上的 MVC 框架而自主开发的一款 JS 库。严格来说 React 是 V 层。</p>
<ul>
<li>轻量级视图库</li>
<li>虚拟DOM</li>
<li>组件系统</li>
<li>单项数据流</li>
<li>JSX语法</li>
</ul>
<p>注：React 中没有指令系统</p>
</blockquote>
<h2 id="React-使用"><a href="#React-使用" class="headerlink" title="React 使用"></a>React 使用</h2><ul>
<li><p>CDN 引入</p>
<ol>
<li><p>React 核心内容</p>
</li>
<li><p>React-dom 渲染真实 dom 的库</p>
</li>
<li><p>babel 编译 JSX 语法</p>
</li>
</ol>
</li>
<li><p>自己搭建 webpack</p>
</li>
<li><p>使用第三方或者官方的脚手架 <code>npx create-react-app &lt;name&gt;</code></p>
<h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2></li>
</ul>
<ol>
<li>单个根元素</li>
<li>单标签一定要闭合</li>
<li>img 标签的 alt 属性一定要有</li>
<li>标签是小写字母，组件首字母大写</li>
<li>class -&gt; className</li>
<li>label 标签不能使用for ，换成 htmlFor</li>
<li>注释：使用 JS 的注释，并且使用 { } ，例如 <code>{ /* &lt;P&gt; &lt;/P&gt;*/ }</code></li>
<li>style 需要写在对象当中<h2 id="JSX-的差值表达式"><a href="#JSX-的差值表达式" class="headerlink" title="JSX 的差值表达式"></a>JSX 的差值表达式</h2>如何在 JSX 中使用变量？</li>
</ol>
<blockquote>
<p>通过 { 变量 } 的差值表达式来使用变量。</p>
</blockquote>
<ul>
<li>差值表达式中能使简单的单个表达式，不能是语句也不能是条件或者循环语句，可以使用三目运算符。</li>
<li>如果想渲染字符串 <code>str = &#39;&lt;h1&gt;qqq&lt;/h1&gt;&#39;</code> ，需要在标签添加属性 <code>dangerouslySetInnerHTML</code> 接受一个对象的 <code>value{__html: str}</code>。</li>
<li>如果要传递参数到标签属性使用 <code>title = {msg}</code>。</li>
<li><code>{ null } | { undefined } | { ‘’ } | { false }</code>没有内容，不会在页面上渲染任何东西。</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><blockquote>
<p>react 没有全局组件的概念，使用哪个组件引入使用<br>组件的函数名直接拿去当标签名<br>React 中组件一共分两种：</p>
</blockquote>
<ol>
<li><p>函数式组件</p>
</li>
<li><p>类组件</p>
<h4 id="函数组件的定义："><a href="#函数组件的定义：" class="headerlink" title="函数组件的定义："></a>函数组件的定义：</h4></li>
<li><p>定义一个函数，然后 return 出来一段 JSX 语法。</p>
</li>
<li><p>函数名字就是组件的名字，首字母大写。</p>
<h4 id="类定义的组件："><a href="#类定义的组件：" class="headerlink" title="类定义的组件："></a>类定义的组件：</h4></li>
<li><p>定义一个类，类名就是组件名 首字母大写。</p>
</li>
<li><p>这个类需要继承于 <code>React.Component</code> 或者 <code>React.PureComponent</code>  基础组件。</p>
</li>
<li><p>类中的 render 函数是必须的，render函数的 return 出来的是一段 JSX 语法。</p>
</li>
</ol>
<p>注：组件的模板内容，如果需要换行去写的话，那么请使用（）包裹起来</p>
<p>没有使用 React，为什么还要去引入?</p>
<blockquote>
<p>JSX 语法是一个语法糖，经过 babel 转换，由于转换出来的代码中使用了 React，所以 React 必须要引入。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; JSX 语法糖</span><br><span class="line">React.createElement(&#39;div&#39;, &#39;参数&#39;, &#39;content&#39;);</span><br></pre></td></tr></table></figure>



<h2 id="组件的-props-属性"><a href="#组件的-props-属性" class="headerlink" title="组件的 props 属性"></a>组件的 props 属性</h2><ul>
<li>props 是个集合， prop 是具体的某一个</li>
<li>Vue 中使用 props 首先需要在组件中定义 props 的选项，而 React 中不需要。</li>
<li>函数组件中所有的 prop 会作为参数传递过来 </li>
<li>类组件所有的 prop 会在 <code>this.props</code> 身上</li>
</ul>
<h3 id="prop-types-校验"><a href="#prop-types-校验" class="headerlink" title="prop-types 校验"></a>prop-types 校验</h3><ol>
<li>安装 prop-types 的模板 <code>npm i --save-dev prop-types</code></li>
<li>引入 prop-types</li>
<li>设置组件的 propTypes 属性</li>
</ol>
<hr>
<p>React 元素 | 虚拟 DOM 元素 | JSX 代码中任意标签 | 通过 React.createElement 创建出来的 JS 对象</p>
<blockquote>
<p>最基本的单元，任何的标签都可以看成是一个 React 元素<br>如何区分 React 元素 与 React 组件的概念<br>组件就是一系列 React 元素的组成<br>什么是元素变量<br>定义一个变量，变量的值是 React 元素<br>React 元素 不是一个可变的对象</p>
</blockquote>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>数据绑定的方式有两种</p>
<ol>
<li>props</li>
<li>state    私有属性<h3 id="有状态组件-amp-无状态组件"><a href="#有状态组件-amp-无状态组件" class="headerlink" title="有状态组件 &amp; 无状态组件"></a>有状态组件 &amp; 无状态组件</h3><blockquote>
<p>组件有没有状态，主要看这个组件有没有 state，一般类组件就可以称为有状态组件，函数组件叫无状态组件</p>
</blockquote>
<h3 id="实现自动跟新，需要让组件有state，当-state-发生变化，他就会重新渲染"><a href="#实现自动跟新，需要让组件有state，当-state-发生变化，他就会重新渲染" class="headerlink" title="实现自动跟新，需要让组件有state，当 state 发生变化，他就会重新渲染"></a>实现自动跟新，需要让组件有state，当 state 发生变化，他就会重新渲染</h3></li>
</ol>
<ul>
<li>组件变化方式<ol>
<li>组件接收到的 props 发生改变</li>
<li>组件自身的 state 有了变化</li>
</ol>
</li>
</ul>
<p>defaultValue / defaultChecked默认值  ，单独使用 Value 会报错需要配合onChange使用</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>挂载</p>
<ul>
<li><p>constructor 构造函数 组件实例化的时候触发，不能在里面 setState。</p>
<ol>
<li>调用父类的构造函数 </li>
<li>super(props) 初始化数据 </li>
<li>绑定this指向</li>
</ol>
</li>
<li><p>componentWillMount()  × 即将过期</p>
</li>
<li><p>static getDerivedStateFromProps()  不常用，能够根据 props 的数据来设置新的 state 数据。</p>
<ol>
<li>初始化 render 之前调用一次</li>
<li>后续数据有变化，重新 render 之前又会调用</li>
<li>不要使用 <code>this.setState</code> -&gt; 哪些不能用？</li>
<li>需要有 return { } | null ，如果是对象，会将 state 合并</li>
</ol>
</li>
<li><p>render () 渲染  默认进来一次，后续如果有更新会再次触发 使用  setState 需要谨慎。</p>
</li>
<li><p>componentDidMount() 组件挂载完成。 </p>
<ol>
<li>获取异步数据</li>
<li>操作 dom</li>
</ol>
</li>
</ul>
<p>更新</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate(nextProps, nextState) 性能优化，这个组件是否需要进行更新渲染？推荐使用 PureComponent 组件继承，两者不能同时存在。需要返回值，返回 true -&gt; 更新生命周期继续执行。false -&gt; 生命周期不执行。</li>
<li>render</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)   真实 DOM 渲染完成的前一刻</li>
<li>componentDidUpdate(<em>prevProps</em>, <em>prevState</em>, <em>snapshot</em>)  更新完成，对 DOM 进行操作，发送网络请求，但是需要正确进行 if 判断。</li>
</ul>
<p>卸载</p>
<ul>
<li>componentWillUnmount  销毁</li>
</ul>
<h2 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h2><h3 id="父-gt-子"><a href="#父-gt-子" class="headerlink" title="父 -&gt; 子"></a>父 -&gt; 子</h3><ul>
<li>通过props</li>
</ul>
<h3 id="子-gt-父"><a href="#子-gt-父" class="headerlink" title="子 -&gt; 父"></a>子 -&gt; 父</h3><ul>
<li>传递方法给子组件，然后子组件调用传递参数</li>
</ul>
<h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><ul>
<li><p>状态提升</p>
</li>
<li><p>第三方中央事件管理器(pubsub)</p>
</li>
<li><p>context</p>
<ol>
<li><code>let MyContext = React.createContext()</code> 创建出一个 context</li>
<li><code>MyContext.Prvider</code> 供应商组件</li>
<li><code>MyContext.Consumer</code> 消费者组件  标签中间需要使用函数返回 JSX，这个函数接受一个参数，这个参数就是供应商中的值。</li>
</ol>
<hr>
<ol>
<li>使用上面的步骤</li>
<li>不使用消费者组件，弄成 <code>x.contextType = MyContext</code>。使用 <code>this.context</code> 获取供应商的数据。</li>
</ol>
</li>
<li><p>React 状态管理器</p>
<ul>
<li><p>官方 flux</p>
</li>
<li><p>第三方  Redux</p>
<ol>
<li><p>任何时刻 state 都没有被改变。</p>
</li>
<li><p>生成一个新的 state 去替换旧的 state，Reducers 不能修改，只能通过 return 纯函数。</p>
<p>Tips：纯函数–任何时候都不会修改参数，有相同的入参，一定会产生相同的出参。</p>
</li>
</ol>
</li>
<li><p>第三方  </p>
</li>
</ul>
</li>
</ul>
<p>Tips：children 类似于 Vue 的插槽</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/08/17/React%E5%9F%BA%E7%A1%80/" data-id="cka9546zt0003s0ula0otbepo" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Vuex" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/07/06/Vuex/">Vuex</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/07/06/Vuex/" class="article-date">
  <time datetime="2018-07-06T01:01:57.000Z" itemprop="datePublished">2018-07-06</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p>
<p>注意：他是一个状态管路模式，切记不要当做数据库使用</p>
</blockquote>
<h2 id="什么时候用vuex"><a href="#什么时候用vuex" class="headerlink" title="什么时候用vuex"></a>什么时候用vuex</h2><blockquote>
<p>用于组件通信，通常在使用了路由之后，不同组件之间的通信， 或者组件之间通信很复杂的时候，这个时候 Vuex 就能帮你进行这个操作。</p>
</blockquote>
<h2 id="Vuex的操作流程"><a href="#Vuex的操作流程" class="headerlink" title="Vuex的操作流程"></a>Vuex的操作流程</h2><ol>
<li>仓库，项目中组件上需要共享的数据放到仓库 state。</li>
<li>组件要使用仓库中state的数据，就从仓库里面</li>
<li>修改仓库中的state<ol>
<li>commit  mutation</li>
<li>派发 action -&gt; commit mutation</li>
</ol>
</li>
<li>仓库中state数据发生变化，组件就会得到更新</li>
</ol>
<h2 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h2><ol>
<li>安装vuex npm i –save vuex</li>
<li>src/store/index.js配置实例对象</li>
<li>main.js vue实例中配置store选项 选项的值就是 2 中的实例对象</li>
</ol>
<h2 id="Vue-router-实例的对象"><a href="#Vue-router-实例的对象" class="headerlink" title="Vue-router 实例的对象"></a>Vue-router 实例的对象</h2><ul>
<li><p>state：数据存放</p>
</li>
<li><p>mutations：修改 state 数据的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    setOne (state, params)&#123;	<span class="comment">//第一个参数为本地state，第二个为传入的参数，传入多个数据使用数组或者对象</span></span><br><span class="line">        state.num = params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>modules：模块</p>
</li>
<li><p>getters：类似于计算属性，参数为 state</p>
</li>
<li><p>actions：异步操作，传入参数需要使用结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">   getCityList (&#123; state, commit &#125;) &#123;	<span class="comment">//comit为mutation方法执行</span></span><br><span class="line">     axios.get(<span class="string">'地址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">     &#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="将仓库中的数据拿到组件中使用"><a href="#将仓库中的数据拿到组件中使用" class="headerlink" title="将仓库中的数据拿到组件中使用"></a>将仓库中的数据拿到组件中使用</h2><ul>
<li><code>this.$store</code> 就是仓库的实例对象  直接使用不推荐</li>
<li>通过计算属性 computed</li>
<li>vuex提供的辅助函数 <code>mapState(&#39;仓库名&#39;,[&#39;state&#39;])</code>  key要和仓库中的相同</li>
</ul>
<p>为了能够将 mapstate 和自身的 computed 结合 ，推荐使用下面这种方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">'demo'</span>, [<span class="string">'demoState'</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'demo'</span>, [<span class="string">'demoState'</span>]),</span><br><span class="line">    ...mapMutations(<span class="string">'demo'</span>, [<span class="string">'setCurFilmType'</span>]),</span><br><span class="line">    fn () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'自定义fn'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="修改仓库中的数据"><a href="#修改仓库中的数据" class="headerlink" title="修改仓库中的数据"></a>修改仓库中的数据</h2><ol>
<li>定义 <code>mutation</code> ，唯一一个可以修改 <code>state</code> 中数据的方法</li>
<li>组件中提交 这个 <code>mutatiion</code><ol>
<li><code>this.$strore.commit(&#39;mutatiion名字&#39;，参数)</code></li>
<li><code>this.$store.commit({
type: mutaion 名字
其他参数
})</code></li>
<li>使用 <code>mapMutation</code> 辅助函数<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3></li>
</ol>
</li>
</ol>
<blockquote>
<p><code>mutation</code> 不允许异步代码，当你在 <code>mutation</code> 中使用异步函数的时候会出现数据刷新不及时。</p>
<p>例如：你设置了一个点击发送请求，获取服务器传递进来的数据。当你点击了按钮，发送请求，并且可能在页面上也渲染出来了，但是你点击 <code>Vue</code> 工具就会发现数据没有改变，再次点击数据是上一次发送请求传回来的数据。有时候你需要对数据进行判断操作的时候，使用 <code>mutation</code> 发送请求就会出现错误。</p>
</blockquote>
<h3 id="actions-写异步代码"><a href="#actions-写异步代码" class="headerlink" title="actions 写异步代码"></a>actions 写异步代码</h3><blockquote>
<p>每一个action里面都可以写异步代码，但是不能修改state里面数据，修改数据的还是 <code>mutaction</code></p>
</blockquote>
<h3 id="推荐在-vuex-moduels-每个模块都加上命名空间"><a href="#推荐在-vuex-moduels-每个模块都加上命名空间" class="headerlink" title="推荐在 vuex moduels 每个模块都加上命名空间"></a>推荐在 vuex moduels 每个模块都加上命名空间</h3><ol>
<li>操作方便</li>
<li>便于模块分类</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/07/06/Vuex/" data-id="cka9546zv0004s0ul194z1zo6" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-vue-小案例" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/07/03/vue-%E5%B0%8F%E6%A1%88%E4%BE%8B/">Vue CLI</a>
    </h2>
  
  
  <div class="article-topping">
    <i class="fe fe-umbrella"></i>
  </div>





            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/07/03/vue-%E5%B0%8F%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2018-07-03T12:27:51.000Z" itemprop="datePublished">2018-07-03</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="Vue-CLI-简单的小案例"><a href="#Vue-CLI-简单的小案例" class="headerlink" title="Vue CLI 简单的小案例"></a>Vue CLI 简单的小案例</h1><blockquote>
<p>Vue CLI 也叫做脚手架工具，前端中一定会用到打包工具 webpakck 但是繁琐的配置问题让人十分头疼，但是 Vue CLI 提供了很好的快速打包配置功能。有着丰富的官方插件，并且还有图形化的创建和管理 Vue 项目的用户界面，可以说真的是 webpack 手残党的福星。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p><strong>Node 版本要求</strong></p>
<p>Vue CLI 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a> 在同一台电脑中管理多个 Node 版本。</p>
</blockquote>
<p>使用以下命令行进行安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># 如果你是用的是 yarn</span></span><br><span class="line">yarn global add @add/cli</span><br></pre></td></tr></table></figure>

<p>如何测试自己是否安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h3><ol>
<li><p>通过以下命令创建一个 Vue 项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个配置的预设方案（回车确键认下一步）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.8.2</span><br><span class="line">? Please pick a preset:    <span class="comment"># 选择预设方案</span></span><br><span class="line">&gt; hello-config (less, babel, eslint)	<span class="comment"># 我之前就配置好并且保存的，后面会遇到的。</span></span><br><span class="line">  default (babel, eslint)	<span class="comment"># 默认设置 </span></span><br><span class="line">  Manually select features	<span class="comment"># 手动选择，这里我们选择这个(你也可以使用默认设置)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手动选择预设功能（空格键选择，<code>a</code>键全选）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.8.2</span><br><span class="line">? Please pick a preset: Manually select features	<span class="comment"># 选择预设</span></span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;(*) Babel	<span class="comment"># ES6 转 ES5 </span></span><br><span class="line"> ( ) TypeScript	<span class="comment"># 支持 TypeScript</span></span><br><span class="line"> ( ) Progressive Web App (PWA) Support	<span class="comment"># 支持 PWA 应用程序</span></span><br><span class="line"> ( ) Router	<span class="comment"># 路由</span></span><br><span class="line"> ( ) Vuex	<span class="comment"># Vue 程序开发的状态管理模式</span></span><br><span class="line"> (*) CSS Pre-processors	<span class="comment"># CSS 预处理器 </span></span><br><span class="line"> (*) Linter / Formatter	<span class="comment"># 规范化语法(魔鬼) </span></span><br><span class="line"> ( ) Unit Testing	<span class="comment"># 单元测试</span></span><br><span class="line"> ( ) E2E Testing	<span class="comment"># E2E 测试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>之后就是对相应的预设功能做一些选择，<code>eslint</code> 选择 <code>ESLint + Standard config</code> 标准设置，config 选择 <code>In dedicated config files</code>，也可以按照你自己的喜好来，这里只是我的设置。之后会提示你是否保存，保存为 xxx 预设名。</p>
</li>
</ol>
<h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><blockquote>
<p>通过 <code>vue ui</code> 的命令进入图形化页面创建和管理项目，具体步骤和上面差不多，而且是图形化很容易就不说了。</p>
</blockquote>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/07/03/vue-%E5%B0%8F%E6%A1%88%E4%BE%8B/" data-id="cka9546zz0008s0ulfhni7g44" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/demo/" rel="tag">demo</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-vue-router" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/07/01/vue-router/">Vue-router</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/07/01/vue-router/" class="article-date">
  <time datetime="2018-07-01T02:04:32.000Z" itemprop="datePublished">2018-07-01</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><blockquote>
<p>创建单页应用，是非常简单的，<strong>这里的路由就是SPA（单页应用）的路径管理器。</strong></p>
</blockquote>
<h2 id="Vue-router-的使用"><a href="#Vue-router-的使用" class="headerlink" title="Vue-router 的使用"></a>Vue-router 的使用</h2><ol>
<li><p>安装 <code>npm i vue-router</code>。</p>
</li>
<li><p>在 <code>src</code> 目录下创建 <code>router</code> 文件夹，并创建 <code>index.js</code> 对其进行路由的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>	<span class="comment">//引入vue-router模块</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;	<span class="comment">//实例化路由对象</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/index'</span>,	<span class="comment">//路径匹配</span></span><br><span class="line">            component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/index.vue'</span>)	<span class="comment">//懒加载，组件位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router	<span class="comment">//暴露</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在 <code>main.js</code> 中引入并且加入 Vue 实例中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>使用组件 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>，通过这个组件可以嵌套路由。</li>
</ol>
<h2 id="router-link-和-router-view"><a href="#router-link-和-router-view" class="headerlink" title="router-link 和 router-view"></a>router-link 和 router-view</h2><blockquote>
<p><code>router-link</code> 是个全局组件，类似于 a标签。to 属性：hash地址，类似于 a 标签的 <code>href</code>。</p>
<p><code>router-view</code> 路由嵌套。</p>
</blockquote>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><blockquote>
<p>使用了 <code>vue-router</code> 以后，在 vue 的实例中添加了 <code>$route</code> 和 <code>$router</code> 两个对象。</p>
<p><code>$route</code> ：当前匹配的路由对象信息，可以获得跳转来自、目的路径、参数等信息传递<br><code>$router</code> ： 路由器的实例对象，可以进行编程式导航。</p>
</blockquote>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><blockquote>
<p>简单的来说，就是通过 JS 代码进行跳转。</p>
</blockquote>
<h3 id="使用-router-对象调用方法进行导航"><a href="#使用-router-对象调用方法进行导航" class="headerlink" title="使用 $router 对象调用方法进行导航"></a>使用 <code>$router</code> 对象调用方法进行导航</h3><ul>
<li><p>push()    跳转页面 新增一个历史记录，该方法接受参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.push(<span class="string">'index'</span>)	<span class="comment">//router中配置的name</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'index'</span> &#125;)</span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'index'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'index'</span>, <span class="attr">query</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)	<span class="comment">// 带查询参数，变成 /index?userId=123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>back()    后退</p>
</li>
<li><p>forward()    前进</p>
</li>
<li><p>go()    根据参数前进还是后退，正数前进，负数后退</p>
</li>
<li><p>replace()    跳转页面 重定向页面 不加历史记录，使用方法和 push 方法相同，通常使用在登录之类</p>
</li>
</ul>
<p><strong>注：name 和 params 搭配 相当于 POST 请求，参数需要通过 $route 获取，name 不能和path使用，path和query搭配 相当于 GET 请求。</strong></p>
<h1 id="路由的两种模式"><a href="#路由的两种模式" class="headerlink" title="路由的两种模式"></a>路由的两种模式</h1><blockquote>
<p><code>router</code> 下的 <code>index.js</code> 中的 <code>router</code> 实例中添加 <code>model: &#39;history&#39;</code></p>
</blockquote>
<ul>
<li><p>hash 默认模式</p>
<p>使用 URL 的 hash 来模拟完整的 URL ，所以当 URL 发生改变的时候，页面不会重新加载，也不会 404 报错，就是外观上略丑。</p>
</li>
<li><p>histroy 模式<br>利用了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，模拟出真实的 URL 路径，但是一刷新就会 404 报错，因为重新请求这个 URL 对应的地址是不存在的，所以需要后台配置相关的路由处理。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li>
</ul>
<ol>
<li>hash模式会在 URL 地址上会有一个 # 号，histroy 没有。</li>
<li>原理上，hash通过 <code>window.onHashChage</code>  这个事件来处理，histroy 基于 HTML5 中 histroy 新增的一些 `api. histroy.pushState(),api.histroy.replaceState(),window.onpoopstat 。</li>
<li>histroy 需要后台配合处理上线的 404 问题。<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1></li>
</ol>
<blockquote>
<p>当我们路由发生改变的时候，可以通过导航守卫做我们想做的。</p>
</blockquote>
<ul>
<li><p>全局守卫</p>
<ul>
<li><p>全局前置  <code>beforeEach()</code> 接收三个参数<br>  to    要去的路由<br>  from    来自哪个路由<br>  next    是否执行 ‘to’ ，直接调用那就相当于放行，如果传递一个false，那么就不放行，不调用不放行，调用并且里面可以传递路由的path路径或者是路由的对象信息，那么就可以重定向我们的参数中所指定的位置。</p>
</li>
<li><p>全局解析守卫 <code>beforeResolve</code></p>
</li>
<li><p>全局后置   <code>afterEach()</code><br>没有 <code>next</code> 参数</p>
</li>
</ul>
</li>
<li><p>路由独享</p>
<pre><code>`beforeRouteEnter`：进入当前组件，**不能访问this，因为此时组件还没被创建**
`beforeRouteUpdate`：当前组件更新
`beforeRouteLeave`：离开当前组件</code></pre></li>
<li><p>组件级别</p>
<h3 id="导航守卫的钩子函数"><a href="#导航守卫的钩子函数" class="headerlink" title="导航守卫的钩子函数"></a>导航守卫的钩子函数</h3></li>
</ul>
<blockquote>
<p>路由发生变化时候主动触发的一些函数</p>
</blockquote>
<h3 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h3><ol>
<li><code>beforeEach,afterEach</code> 实现页面进度条</li>
<li>登录拦截</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/07/01/vue-router/" data-id="cka9546zx0007s0uld5bd0kg7" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Vue-组件" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/06/29/Vue-%E7%BB%84%E4%BB%B6/">Vue 组件</a>
    </h2>
  
  
  <div class="article-topping">
    <i class="fe fe-umbrella"></i>
  </div>





            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/06/29/Vue-%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2018-06-29T09:22:18.000Z" itemprop="datePublished">2018-06-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h1><blockquote>
<p>组件是 vue.js 最强大，也是最重要的功能之一。组件可以拓展 HTML 元素，并且对其进行封装重用的代码，提高代码的复用性。所有的 vue 组件同时也都是 vue 的实例。</p>
</blockquote>
<h2 id="怎么去注册组件？"><a href="#怎么去注册组件？" class="headerlink" title="怎么去注册组件？"></a>怎么去注册组件？</h2><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><ul>
<li><p>全局注册组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'组件名'</span>,&#123;<span class="string">'选项对象'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>组件对象是相当于 HTML 中的标签中使用，特别注意以下两点：</p>
<ol>
<li>全局注册的组件需要在 Vue 所在挂载点的实例之前，否则会出现组件未注册的报错。</li>
<li>组件可以认为是 vue 的实例，但是选项对象中不能使用 <code>el</code> 和 <code>propsData</code></li>
</ol>
</li>
<li><p>局部注册组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'组件名'</span>: &#123;</span><br><span class="line">            <span class="string">'选项对象'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册的可以在同一个 vue 实例中创建多个组件</p>
</li>
</ul>
<h3 id="组件的选项对象"><a href="#组件的选项对象" class="headerlink" title="组件的选项对象"></a>组件的选项对象</h3><blockquote>
<p>组件的选项对象中一定要有 <code>template</code> ，因为这是渲染到页面中的模板。组件可以认为是 vue 的实例，但是选项对象中不能使用 <code>el</code> 和 <code>propsData</code></p>
</blockquote>
<ul>
<li><p><code>template</code>  </p>
<p>组件的选项对象中需要用 <code>template:&quot;&lt;p&gt;组件&lt;/P&gt;&quot;</code> 选项去定义模板，而且可以使用模板字符串，但是有时候这种方法总显得很复杂，所以有几种方法供我们使用：</p>
<ol>
<li><p>直接使用 “ “ 或者 `` ，在模板字符串中你可以随意的换行，但是没有代码提示和高亮。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`&lt;button&gt; 这是组件 &lt;/button&gt;`</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>利用 <code>template</code> 标签的特性，将组件里面 <code>template</code> 内容写在标签内，然后组件的 <code>template</code> 的值填 <code>template</code> 标签的 id 。<code>template: &#39;#template-box&#39;</code></p>
<p>Tips：<code>template</code> 标签不会被渲染出来，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"template-box"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span>组件的a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>注：`template` 标签内只能有一个根节点，如果你要使用多个标签，就需要用一个标签，如上面的 div 包裹住，否则会有 `Error compiling template` 报错，提示你只能有一个根节点。</code></pre><ul>
<li><p><code>data</code></p>
<p>在 vue 的实例中，<code>data</code> 选项可以直接使用，但是在组件中需要以函数的方式，并且使用· <code>return</code> 来返回数据对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-tag'</span>,&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">                msg: <span class="string">'这是组件的data中的msg'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">	template:<span class="string">'&lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  因为组件通常是循环使用的，然后如果你组件还是直接使用 <code>data:{ msg: &#39;msg&#39;}</code> 的方式的话，这里就有一个问题，这里的 <code>data</code> 是引用类型传参，你的多个 <code>my-tag</code> 组件都是指向同一个 <code>msg</code> ，当你只想修改其中一个的时候，这里就会造成全都被修改的问题，所以需要使用 <code>return</code> ，这样每次都是一个不同地址的数据对象。</p>
<ul>
<li><p><code>props</code></p>
<blockquote>
<p>这里涉及到了组件的嵌套，我们后面再提。现在需要知道的是父组件传数据给子组件时，子组件需要由 <code>props</code> 来获取，并且<strong><code>props</code> 中的数据不能被修改！</strong>准确来说是能被修改，但是会报错，所以要修改数据，就在父组件的<code>data</code> 去修改。</p>
</blockquote>
</li>
</ul>
<p>其他的对象选项和 vue 实例中基本相同</p>
<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><blockquote>
<p>通过标签的形式去使用，将组件名当做标签名在挂载点内使用，标签内任何内容都会被 <code>component</code> 选项覆盖。</p>
<p><strong>注：如果组件名是 newBox 驼峰命名法，那么使用的时候标签名需要改成 <code>&lt;new-box&gt;&lt;/new-box&gt;</code>，标签也可以使用单标签哦，注意闭合。</strong></p>
<p>props 的驼峰命名法也会有这个问题，因为在 HTML 会把大写字符解释为小写，如果使用字符串模板就不会有这个问题。所以在父组件传递参数给子组件时候需要在 HTML 内容中写例： <code>&lt;com-one :p-msg=&quot;msg&quot;&gt;&lt;/com-one&gt;</code>，但是在子组件的 <code>props</code> 中是 <code>props:[&#39;pMsg&#39;]</code>。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">new-box</span>&gt;</span><span class="tag">&lt;/<span class="name">new-box</span>&gt;</span>	//自定义组件</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h2><blockquote>
<p>在某些时候，我们需要对组件进行一个嵌套，而 vue 的组件嵌套时很简单，只需要在父组件中添加子组件标签即可。</p>
<p>这个例子涉及到了组件通信的问题，不要慌，继续往下看。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">:app-msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">     &#123;&#123; msg &#125;&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el: <span class="string">'#app'</span>,</span></span><br><span class="line">        	data: &#123;</span><br><span class="line"><span class="actionscript">             msg: <span class="string">'父组件的msg'</span></span></span><br><span class="line">         &#125;,</span><br><span class="line">         components: &#123;</span><br><span class="line">             child: &#123;</span><br><span class="line">                 data() &#123;</span><br><span class="line"><span class="actionscript">                     <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                         msg: <span class="string">'子组件的msg'</span>,</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;,</span><br><span class="line"><span class="actionscript">                 props: [<span class="string">'appMsg'</span>],                   </span></span><br><span class="line"><span class="handlebars"><span class="xml">                 template: '<span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"> ----- 这是子组件的P标签----- </span><span class="template-variable">&#123;&#123; appMsg &#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span></span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>执行结果为：<code>子组件的msg ----- 这是子组件的P标签-----父组件的msg</code></p>
<p><strong>注意：不要踩命名的坑，之前说到当你 <code>template</code> 不是模板字符串的方式的时候，你需要注意标签名是横杠连接写法（这里讲的俗点）。但是还需要注意的一个点就是在 <code>:app-msg=&#39;msg&#39;</code> ，尽量注意，如果你使用驼峰命名法子组件使用时候接受的也是全小写！你使用的是 - 连接时候，使用的时候就需要是 驼峰式。我也是晕的很，这个还是自己要注意，并且多多实践。模板字符串一劳永逸呀。</strong></p>
<p>PS：自定义事件用<code>kebab-case</code>（- 链接）, 自定义属性用<code>camelCased</code>（驼峰式）</p>
<h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><blockquote>
<p>有时候我们可能会碰到一些情况，就是子组件要获取或者修改父组件中的数据，又或者是父组件去访问子组件中的数据。但是不能直接去访问，需要通过一些方法来实现。</p>
</blockquote>
<ul>
<li><code>ref</code> 在元素上添加 <code>ref=&#39; &#39;</code>，然后可以在组件中使用方法 <code>this.$refs</code> 获取到与其相关联的组件。（不推荐）</li>
</ul>
<h3 id="父组件传递数据给子组件"><a href="#父组件传递数据给子组件" class="headerlink" title="父组件传递数据给子组件"></a>父组件传递数据给子组件</h3><ol>
<li><p>在父组件中使用子组件的时候自定义一个指令，用于接受父组件传递的数据。</p>
<p>子模板中自定义指令 <code>app-msg</code> ，<code>msg</code> 是父组件 data 中的数据，需要对应名称！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>	//父组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:app-msg</span>=<span class="string">"msg"</span> <span class="attr">ref</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span>	//子组件</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>子组件中通过 <code>props</code>选项，子组件获取到父组件传递进来的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> components: &#123;</span><br><span class="line">      child: &#123;</span><br><span class="line">  	  props: ['app-msg'],</span><br><span class="line">  	 template: '<span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span>  ----- 这是子组件的P标签-----&#123;&#123; appMsg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h3><blockquote>
<p>这个方法也可以用作子组件去调用父组件的方法。</p>
</blockquote>
<ol>
<li><p>同样的，使用子组件的时候，自定义一个事件，父组件传递方法名给这个事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>  @<span class="attr">son-fn</span>=<span class="string">"fn"</span> &gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>子组件使用 <code>@click</code> 或其他事件触发，在事件中使用 <code>this.$emit</code> 去调用父组件中的事件，同时，这里可以传子组件的参数，实现子组件传递数据给父组件。</p>
<p>父组件中的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    fn(s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = s;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'父组件的fn方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   子组件通过自定义的事件获取到了父组件中的方法，在 <code>template</code> 使用 <code>@click</code>去调用：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sonMsg: <span class="string">'巴拉巴拉巴拉'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fnn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs);</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'son-fn'</span>, <span class="keyword">this</span>.sonMsg);	<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">props: [<span class="string">'app-msg'</span>],</span><br><span class="line">template: <span class="string">'&lt;p @click="fnn"&gt; ----- 这是子组件的P标签-----&#123;&#123; appMsg &#125;&#125; &lt;/p&gt;'</span></span><br></pre></td></tr></table></figure>



<p>   this.$emit` 参数是第一个为方法名称，这个是在 DOM 中自定义的方法名，后面为传入的参数。</p>
<h3 id="我的理解："><a href="#我的理解：" class="headerlink" title="我的理解："></a>我的理解：</h3><ul>
<li><p>首先是父组件传递数据给子组件，因为在 <code>&lt;div id=&quot;app&quot;&gt;</code> 标签中就是在父组件中，此时你可以传入任何父组件里面的数据，而子组件自定义的指令接受到了，相当于获取到了传递的值。</p>
</li>
<li><p>子组件传递父组件使用的可以认为是回调函数的一种方法，然后通过传入参数去把子组件的参数传递给父组件当中。具体看图：</p>
<p><img src="/medias/images/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.png" alt="父子组件通信"></p>
</li>
</ul>
<h2 id="兄弟组件以及复杂关系之间的通信"><a href="#兄弟组件以及复杂关系之间的通信" class="headerlink" title="兄弟组件以及复杂关系之间的通信"></a>兄弟组件以及复杂关系之间的通信</h2><h3 id="子传父，然后父传子"><a href="#子传父，然后父传子" class="headerlink" title="子传父，然后父传子"></a>子传父，然后父传子</h3><h3 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h3><h3 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h3><p>前两种在官方中很详细，所以这里重点简述一下中央事件总线，因为 <code>$on和$emit</code> 需要在同一公共的实例才能触发，所以我们可以创建一个 Vue 实例专门去放置事件</p>
<ol>
<li><p>创建中央 <code>var bus = new Vue()</code></p>
</li>
<li><p>在兄弟组件 A 中添加 <code>mounted</code>生命周期函数，挂载点挂载的时候自动开启监听，这里相当于把组件 A 的函数传递给 <code>bus</code> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">    bus.$on(<span class="string">'fn'</span>,(val)=&gt;&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = val;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在兄弟组件 B 中调用 <code>$emit(&#39;fn&#39;, this.name)</code>方法，并且传入组件 B 中的参数，实现兄弟组件或者复杂组件之间的通信</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`&lt;div&gt;&lt;p&gt; &#123;&#123; name &#125;&#125; &lt;/p&gt;&lt;button @click="fnn"&gt;点我&lt;/button&gt;&lt;/div&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        fnn() &#123;</span><br><span class="line">            bus.$emit(<span class="string">'fn'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>在组件的标签内容中，填写任何内容，都会被 <code>template</code> 模板内容所覆盖，但是有时候我们需要的确实另外的效果，希望标签内的内容能够被保留，这时候就需要用到插槽。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">	这是插槽内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>template</code> 中添加 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签，组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 就会被替换成 “这是插槽内容”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">"&lt;div&gt; &lt;p&gt;这是一个p&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;"</span></span><br></pre></td></tr></table></figure>

<p>并且，在模板内容中的 <code>slot</code> 标签中你可以添加任意 HTML 元素，甚至是其他组件，模板标签内的内容就叫做后备内容。当你组件中没有写任何内容的时候，就会渲染出这些内容，可以理解为备用内容。新语法中 <code>template</code> 才可以使用 <code>v-slot</code> 。</p>
<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><blockquote>
<p>当你想在插槽中使用数据的时候，你可以要注意到此时的编译作用域问题。</p>
<p><strong>官方提示：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>你们慢慢木<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">           data () &#123;</span><br><span class="line">               <span class="keyword">return</span> &#123;</span><br><span class="line">                   msg: <span class="string">'666'</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           template: <span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;slot name="up"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">               &lt;button&gt;123&lt;/button&gt;</span></span><br><span class="line"><span class="string">               &lt;slot name="down"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">               &lt;slot&gt;&#123;&#123; msg &#125;&#125;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">           `</span></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<p>这个时候因为 msg 的使用是在子组件的 <code>template</code>中调用编译的，所以就是子组件中的 msg。相反，如果你在 <code>div#app</code> 标签中使用 <code></code> 那么编译的就是父组件中的 msg，这一点很重要，可以参考父组件向子组件传递数据，子组件通过自定义指令接受，自定义指令的等号后面就是父组件的内容。</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote>
<p>顾名思义，这是一个有着具体名称的插槽，可以认为是有钥匙和锁对应的插槽。</p>
<p>在正常情况下，插槽内容都会被加入到插槽模板标签中，也称为默认插槽。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-slot:cha</span>&gt;</span>你们慢慢木<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span> &gt;</span>巴拉巴拉的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时的第一个 P 标签就被上锁了，在子组件的模板内容中直接使用 <code>slot</code> 是获取不到的，因为你没有钥匙，钥匙就是在 <code>slot</code> 标签上面添加 <code>name=&quot;cha&quot;</code>，对应插槽内容中，这就叫做具名插槽。</p>
<h2 id="非-props-特性"><a href="#非-props-特性" class="headerlink" title="非 props 特性"></a>非 props 特性</h2><blockquote>
<p>什么是 props ？</p>
<p>当父组件向子组件传递数据的时候，子组件需要使用 <code>props</code> 选项去接收传递过来的数据，但是如果父组件传递下来，但是子组件并没有使用 <code>props</code> 去接收，那么这些传递过来的属性就会有一些特性。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:age</span>=<span class="string">"age"</span> <span class="attr">:name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    <span class="comment">// inheritAttrs:false,//非props特性不让你覆盖  </span></span><br><span class="line">    template: <span class="string">`&lt;div  name='qqq'&gt;</span></span><br><span class="line"><span class="string">                  &lt;p&gt; &#123;&#123; msg &#125;&#125; &#123;&#123; $attrs &#125;&#125; &lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;/div&gt; `</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        age: &#123;</span><br><span class="line">            type: <span class="built_in">String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">'这是个 msg '</span>,</span><br><span class="line">            name: <span class="string">'lemon'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是个 msg &#123; <span class="string">"name"</span>: <span class="string">"qfl"</span> &#125;   <span class="comment">-----输出的结果</span></span><br></pre></td></tr></table></figure>

<p>此时的 name 就是非 props 特性：</p>
<ul>
<li><p>能够被 <code>$attrs</code> 获取到</p>
</li>
<li><p>非props特性自动写入根元素上覆盖，渲染出来的子组件标签上面的 <code>name</code>不是 qqq ，而是传递过来的父组件中的 name 值</p>
<p>非 props 特性会覆盖子组件模板 <code>template</code>上面相同的值。</p>
<p><strong>注：<code>class</code> 和 <code>style</code> 两大流氓不受影响，会合并。</strong></p>
</li>
<li><p>通过 <code>inheritAttrs:false</code>选项可以拦截不让 name 覆盖，但是还是能被 <code>$attrs</code>，这里是不受影响的。</p>
</li>
</ul>
<h3 id="能做些什么呢-？"><a href="#能做些什么呢-？" class="headerlink" title="能做些什么呢 ？"></a>能做些什么呢 ？</h3><blockquote>
<p>当我们不想传递到子组件的根元素使用，而是想子元素使用这些属性的时候，并且属性较多，我们不想一个一个在 <code>data</code> 中去 return ，繁琐而且容易遗漏出错。</p>
<p><code>inheritAttrs:false</code>和 <code>$attrs</code> 可以实现让子组件模板里的子标签能够使用。在需要使用的地方，比如上面的子组件的 P 标签中，我们不需要一个个去写，直接 <code>v-bind=&quot;@attrs&quot;</code>，注意这里不能简写成 ：。</p>
<p>注意： <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>
</blockquote>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="BUS-的原理是什么？"><a href="#BUS-的原理是什么？" class="headerlink" title="BUS 的原理是什么？"></a>BUS 的原理是什么？</h3><blockquote>
<p>我的理解就是，通过中央事件管理器存放监听的方法，然后执行的时候再到这里来调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = &#123;&#125;;	<span class="comment">//存放各种方法</span></span><br><span class="line"><span class="keyword">var</span> bus = &#123;	<span class="comment">//中央处理</span></span><br><span class="line">    $on: <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fun[eventName])&#123;	<span class="comment">//不存在创建</span></span><br><span class="line">            fun[eventName] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        fun[eventName].push(callback);</span><br><span class="line">    &#125;,  </span><br><span class="line">    $emit: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, params</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fun[eventName])&#123;	<span class="comment">//存在方法</span></span><br><span class="line">            fun[eventName].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">                cb(params);	<span class="comment">//</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="v-model-的原理是怎样的呢？"><a href="#v-model-的原理是怎样的呢？" class="headerlink" title="v-model 的原理是怎样的呢？"></a>v-model 的原理是怎样的呢？</h3><blockquote>
<p>首先是通过 <code>:value=&quot;value&quot;</code> 指令获取到 data 中的 value 值，实现单向的 value 绑定输入框内容显示。然后再通过事件 <code>@input=&quot;value=$evnet.target.value&quot;</code> 当你输入值，调用事件修改 data 中的 value 值实现双向绑定。这里需要注意的是单选框和复选框用的是 <code>@change</code>。</p>
</blockquote>
<h3 id="修饰符-sync-语法糖的原理"><a href="#修饰符-sync-语法糖的原理" class="headerlink" title="修饰符 sync 语法糖的原理"></a>修饰符 sync 语法糖的原理</h3><h3 id="内置组件有哪些？"><a href="#内置组件有哪些？" class="headerlink" title="内置组件有哪些？"></a>内置组件有哪些？</h3><blockquote>
<p><code>component</code></p>
<p><code>template</code></p>
<p><code>slot</code></p>
</blockquote>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/06/29/Vue-%E7%BB%84%E4%BB%B6/" data-id="cka9546zw0005s0ul985d8f1w" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
      </nav>
    
  </section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 oneQiu Blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="oneQiu Blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/links">链接</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>


  
  {% include '_third-party/comments/index.swig' %}
  <script type="text/javascript" src="./js/clicklove.js"></script>
  <script type="text/javascript" src="./js/snow.js"></script>
  <!--彩带2.自动飘动-->
  
</body>

</html>