<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小程序奇葩坑点</title>
      <link href="/2020/05/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9D%91/"/>
      <url>/2020/05/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="小程序坑点总结"><a href="#小程序坑点总结" class="headerlink" title="小程序坑点总结"></a>小程序坑点总结</h1><h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><blockquote><p>可怜的我在产品的逼迫下，要在PC微信和PC企业微信都能完美运行小程序。四月份的时候，PC微信有了小程序面板，然后我就开始了写bug之路。</p></blockquote><h2 id="PC微信小程序没有首页按钮"><a href="#PC微信小程序没有首页按钮" class="headerlink" title="PC微信小程序没有首页按钮"></a>PC微信小程序没有首页按钮</h2><blockquote><p>小程序在使用的时候，会根据判断路由信息是否为空，如果为空，会在导航栏自动生成一个首页的按钮。在PC微信中，小程序并不会去根据路由信息判断，</p></blockquote><p>触发场景：</p><ul><li>当你使用<code>wx.reLaunch</code>或者<code>wx.redirectTo</code>使得当前路由为空的时候，并不会出现回到首页的按钮。</li><li>直接跳到非首页路由页面</li></ul><p>解决方法：</p><ul><li>非首页页面添加侧边快捷操作按钮，这个可以作为一个组件，不过相对比较麻烦，而且会遮挡页面内容</li><li>使用自定义导航栏，好用，但是部分场景会引发的Bug就比较扎心了，自定义导航栏另外介绍。</li></ul><h2 id="上传图片无效"><a href="#上传图片无效" class="headerlink" title="上传图片无效"></a>上传图片无效</h2><blockquote><p>小程序上传文件我们使用<code>wx.uploadFile</code>，然后我在官方文档看到这么一句话。</p><p> 将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 <code>content-type</code> 为 <code>multipart/form-data</code>。 </p><p>PS：正是因为这一句话，引发了我这次寻Bug之旅，企业微信联系了小程序官方问这个问题，他们表示没复现出来。</p></blockquote><p>触发场景：</p><ul><li><code>wx.uploadFile</code>中添加了<code>content-type: multipart/form-data</code></li><li>在PC微信或者PC企业微信中运行小程序进行上传图片</li></ul><p>解决方法：</p><ul><li>去掉<code>content-type: multipart/form-data</code></li></ul><h2 id="PC端运行小程序"><a href="#PC端运行小程序" class="headerlink" title="PC端运行小程序"></a>PC端运行小程序</h2><p>企业微信</p><ul><li>企业微信暂只支持运行正式版小程序，不能唤起体验版，包括分享体验版也是无法使用</li></ul><p>微信</p><ul><li>可以使用所有版本的小程序</li></ul><p>Tips：如果你要在PC微信运行开发版，通常有这几种方法</p><ul><li>截图二维码发在微信上，微信现在可以扫描图片二维码</li><li>在微信开发者工具中打开通用设置 -&gt; 启动PC端自动预览</li></ul><h2 id="微信开发者工具反复横跳"><a href="#微信开发者工具反复横跳" class="headerlink" title="微信开发者工具反复横跳"></a>微信开发者工具反复横跳</h2><blockquote><p>某些场景下我们可能需要手动操作返回，比如使用<code>wx.navigateBack</code>，然后在使用小程序自带的返回键会在两个页面来回跳动</p></blockquote><p>触发场景：</p><ul><li>部分页面自定义导航栏</li><li>仅仅出现在微信开发者工具上面</li></ul><p>解决方法：</p><ul><li>无视。。。因为，实际用起来并不会这样，只是在开发者工具上会这样，很奇怪</li><li>全部使用自定义导航栏</li></ul><h2 id="PC小程序不支持chooseMessageFile"><a href="#PC小程序不支持chooseMessageFile" class="headerlink" title="PC小程序不支持chooseMessageFile"></a>PC小程序不支持<code>chooseMessageFile</code></h2><blockquote><p>现在的小程序可以通过<code>wx.chooseMessageFile</code>去选择图片以外的各种格式的文件。辣么，问题来了，在PC上会提示<code>chooseMessageFile:fail:not supported</code>。在<code>Ststem</code>中你会发现版本号明明比这个<code>API</code>高呀。但是还是会这样，企业微信上联系了小程序助手，emm，暂时无解。</p></blockquote><h2 id="页面底部的input框在输入时会把自定义导航栏挤掉"><a href="#页面底部的input框在输入时会把自定义导航栏挤掉" class="headerlink" title="页面底部的input框在输入时会把自定义导航栏挤掉"></a>页面底部的<code>input</code>框在输入时会把自定义导航栏挤掉</h2><blockquote><p>自定义导航栏也算页面内容，所以也是会被强制位移</p></blockquote><p>触发场景：</p><ul><li>自定义导航栏 &amp;&amp; 页面底部有输入框</li></ul><p>解决方法：</p><ul><li><p>尽量避免在页面底部出现输入框</p></li><li><p>监听文本框<code>bindblur   bindfocus</code>事件，在聚焦时候动态改变页面的<code>padding-bottom</code></p><p> <code>event.detail = { value, height }，height 为键盘高度</code></p></li><li><p>设置 <code>input</code> 的 <code>adjust-position</code> 为 <code>false</code>，不自动上推，用 <code>wx.pageScrollTo</code> 来自定义上推行为 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考时间</title>
      <link href="/2019/05/31/%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4/"/>
      <url>/2019/05/31/%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bug</title>
      <link href="/2019/05/29/bug/"/>
      <url>/2019/05/29/bug/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="在-router-link标签上绑定事件"><a href="#在-router-link标签上绑定事件" class="headerlink" title="在 router-link标签上绑定事件"></a>在 <code>router-link</code>标签上绑定事件</h3><blockquote><p>添加修饰符 <code>.native</code></p></blockquote><h3 id="使用-kepp-alive-标签使用-include控制组件缓存"><a href="#使用-kepp-alive-标签使用-include控制组件缓存" class="headerlink" title="使用 kepp-alive 标签使用 include控制组件缓存"></a>使用 <code>kepp-alive</code> 标签使用 <code>include</code>控制组件缓存</h3><blockquote><p>使用多组时候，使用逗号隔开，但是不能有空格</p></blockquote><h3 id="滚动条不同组件复用"><a href="#滚动条不同组件复用" class="headerlink" title="滚动条不同组件复用"></a>滚动条不同组件复用</h3><blockquote></blockquote><h3 id="JS-数组排序-a-z"><a href="#JS-数组排序-a-z" class="headerlink" title="JS 数组排序 a-z"></a>JS 数组排序 a-z</h3><p>这里有一组字符串的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"M"</span>,<span class="string">"U"</span>,<span class="string">"Z"</span>,<span class="string">"H"</span>,<span class="string">"B"</span>,<span class="string">"K"</span>,<span class="string">"S"</span>,<span class="string">"N"</span>,<span class="string">"T"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>,<span class="string">"J"</span>,<span class="string">"I"</span>,<span class="string">"T"</span>,<span class="string">"I"</span>,<span class="string">"R"</span>,<span class="string">"P"</span>,<span class="string">"R"</span>,<span class="string">"C"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"C"</span>,<span class="string">"P"</span>,<span class="string">"M"</span>,<span class="string">"D"</span>,<span class="string">"H"</span>,<span class="string">"B"</span>,<span class="string">"N"</span>,<span class="string">"G"</span>,<span class="string">"B"</span>,<span class="string">"A"</span>];</span><br></pre></td></tr></table></figure><p>对其进行排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;<span class="keyword">return</span> v1&gt;v2&#125;);</span><br><span class="line">/[<span class="string">"P"</span>, <span class="string">"A"</span>, <span class="string">"R"</span>, <span class="string">"M"</span>, <span class="string">"B"</span>, <span class="string">"K"</span>, <span class="string">"B"</span>, <span class="string">"G"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"J"</span>, <span class="string">"I"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"D"</span>, <span class="string">"M"</span>, <span class="string">"H"</span>, <span class="string">"C"</span>, <span class="string">"C"</span>, <span class="string">"C"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"N"</span>, <span class="string">"N"</span>, <span class="string">"P"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"Z"</span>]</span><br></pre></td></tr></table></figure><p>这个结果是我们不想要的，但是按道理没错误鸭。</p><p>解决方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1&gt;v2?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新"><a href="#vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新" class="headerlink" title="vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新"></a>vuex里面的sotre数据改变，但是没有触发getter并没触发，视图也不更新</h4><p><strong>Vue 封装组件，然后传参，引用类型，出现了联动问题</strong></p><blockquote><ol><li>传值时候使用 concat 让他成为一个新数组</li><li>扩展运算符</li><li>return</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux</title>
      <link href="/2018/09/24/Redux/"/>
      <url>/2018/09/24/Redux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>引入 redux <code>import redux from &#39;redux&#39;</code></li><li>创建 strore 实例对象 <code>const store = redux.createStore((state, action) =&gt; { return xxx })</code> 这个函数默认进来一次，可以做为仓库的初始化工作。</li><li>暴露 store <code>export default store</code></li></ol><ul><li>获取仓库中的数据 <code>store.getState().xxx</code></li></ul><h2 id="修改仓库的数据"><a href="#修改仓库的数据" class="headerlink" title="修改仓库的数据"></a>修改仓库的数据</h2><p><code>store.dispatch(action)</code> 派发一个动作</p><h2 id="组件得到-store-改变之后修改自身数据"><a href="#组件得到-store-改变之后修改自身数据" class="headerlink" title="组件得到 store 改变之后修改自身数据"></a>组件得到 store 改变之后修改自身数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe()</span><br></pre></td></tr></table></figure><p>Reducer 返回一个新的 state，真正修改的是 state</p><h2 id="action-是什么？"><a href="#action-是什么？" class="headerlink" title="action 是什么？"></a>action 是什么？</h2><blockquote><p>action 就是一个包含 type 和 value 的对象</p></blockquote><ul><li><code>return Object.assign({}, state, { name: action.value })</code></li><li><code>return { ...state, name: action.value }</code></li><li><code>let newState = {...state};return newState</code></li><li><code>let newState = JSON.parse(JSON.stringify(state))</code></li></ul><h2 id="action-创建函数"><a href="#action-创建函数" class="headerlink" title="action 创建函数"></a>action 创建函数</h2><h2 id="reducer-拆分"><a href="#reducer-拆分" class="headerlink" title="reducer 拆分"></a>reducer 拆分</h2><h2 id="ANTD"><a href="#ANTD" class="headerlink" title="ANTD"></a>ANTD</h2><h2 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h2><h3 id="redux-ogger"><a href="#redux-ogger" class="headerlink" title="redux-ogger"></a>redux-ogger</h3><h3 id="redyx-thunk"><a href="#redyx-thunk" class="headerlink" title="redyx-thunk"></a>redyx-thunk</h3><blockquote><p>这个中间件的使用，让我们 <code>store.dispatch</code> 能支持接收到函数，以前只支持对象。</p><p>闭包</p><p>dom 对象  ie 低版本 内存泄漏</p></blockquote><h3 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h3><h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="UI-组件与容器组件"><a href="#UI-组件与容器组件" class="headerlink" title="UI 组件与容器组件"></a>UI 组件与容器组件</h3><h4 id="UI-组件（展示组件）"><a href="#UI-组件（展示组件）" class="headerlink" title="UI 组件（展示组件）"></a>UI 组件（展示组件）</h4><blockquote><p>一般来说 UI 组件，只负责 UI 的渲染，不负责数据的情况，它不需要 state 数据，它上面的数据全是容器组件来通过 props 传递下来的。所以一般我们可以将 UI 组件写成 function 组件。</p></blockquote><h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><blockquote><p>它麦处理数据，负责跟 redux 打交道。</p></blockquote><hr><ul><li><code>connect(mapStateToprops, mapDispatchToprops)(UI 组件)</code></li><li>Provider 组件</li></ul><ol><li><code>yarn add react-redux</code></li><li>项目入口，使用 Provider 组件将 store 的数据 context 下去。</li><li>实现 UI 组件，由 connect 帮我们去创建容器组件。</li></ol><h2 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h2><ul><li>react-router                                Link</li><li>react-router-dom（推荐） NavLink    高亮效果</li></ul><h3 id="提供的路由相关组件"><a href="#提供的路由相关组件" class="headerlink" title="提供的路由相关组件"></a>提供的路由相关组件</h3><ul><li><p>路由组件（全局只能有一个）</p><ul><li><p>BrowserRouter        history模式</p></li><li><p>HashRouter                hash模式</p></li></ul><p>表现形式不同    原理不同</p></li><li><p>单个的路由规则组件</p><ul><li>Route</li></ul></li><li><p>全局路由</p><ul><li>Router</li></ul></li><li><p>导航组件</p><ul><li>Link</li><li>NavLink</li></ul></li><li><p>只匹配一条规则</p><ul><li>Switch    从上往下渲染，只匹配第一条</li></ul></li><li><p>Redirect</p></li><li><p>widthRouter    方法    高阶组件</p></li></ul><h3 id="路由界面自动接收到的三个-prop，路由页面组件中的其他组件是获取不到的。"><a href="#路由界面自动接收到的三个-prop，路由页面组件中的其他组件是获取不到的。" class="headerlink" title="路由界面自动接收到的三个 prop，路由页面组件中的其他组件是获取不到的。"></a>路由界面自动接收到的三个 prop，路由页面组件中的其他组件是获取不到的。</h3><ul><li>history<ul><li><code>push()</code></li><li><code>replace()</code></li><li><code>go()</code></li><li><code>goBack()</code></li><li><code>goForward()</code></li></ul></li><li>location<ul><li>search  query 的参数</li></ul></li><li>match<ul><li>params 动态路由</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 生命周期</title>
      <link href="/2018/09/23/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/09/23/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h1><blockquote><p>在 React 中开始创建到销毁有着一系列的生命周期，对此，我表达一下自己对 React 生命周期的理解哈。</p></blockquote><p>首先贴一张 React 官方的生命周期图</p><p><a href="/medias/images/React-live.png">React-生命周期</a></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol><li><p><code>constructor(props)</code> 构造函数</p><ul><li><p>在 React 创建时，调用一次 <code>constructor</code> 。</p></li><li><p>参数 props，获取父组件传入的数据。</p></li><li><p>能做些什么？</p><ol><li><code>super(props)</code> 可以理解为修改当前 this 指向，如果你要在后面正确的使用当前的 this，那么就一定需要。</li><li>统一修改事件方法的 this 指向（事件方法修改 this 指向的方法之一），例：<code>this.onClick = this.onClick.bind(this)</code>。</li><li>初始化 state，例：<code>this.setState = { name: &#39;cxk&#39; }</code>。</li></ol></li></ul></li><li><p><code>static getDerivedStateFromProps(nextProps, nextState)</code> 静态方法 从 props 派生 state</p><ul><li><p>props | state 变化前，对其进行操作。</p></li><li><p>参数 <code>nextProps, nextState</code> 获取变化之后的数据。</p></li><li><p>需要 <code>return</code> 返回值，返回 state，如果不需要修改 state 值，那么直接 <code>return null</code>。</p></li><li><p>在此方法里面不能获取到 <code>this</code>。</p></li><li><p>可以认为此方法替代了 <code>componentWillMount</code>。</p></li></ul></li><li><p><code>render()</code> 渲染 DOM</p></li><li><p><code>componentDidMount(prevProps, prevState)</code> 组件挂载完成</p><ul><li>参数 <code>prevProps,prevState</code> 修改之前的参数。</li><li>可以获得当前组件的 <code>this</code>，所以可以使用 <code>setState</code>，它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</li><li>这里适合发起网络请求去获取数据。</li></ul></li></ol><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol><li><code>static getDerivedStateFromProps(nextProps, nextState)</code> </li><li><code>shouldComponentUpdate(nextProps, nextState)</code> 组件是否更新<ul><li>需要 <code>return</code> 返回值，返回波尔值，如果返回 <code>true</code> 则正常进行更新，返回 <code>false</code> 中断当前更新。</li><li>能获取到 <code>this</code>。</li></ul></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code> 在组件更新前一刻<ul><li>能够获取 <code>this</code>。</li><li>需要一个 <code>return</code> 返回值，这个数据将会在 <code>componentDidUpdate</code> 中以第三个参数 <code>snapshot</code> 所获取到。</li></ul></li><li><code>componentDidUpdate(prevProps, prevState, snapshot)</code> 组件更新完成<ul><li>能获取到 <code>this</code>。</li><li>第三个参数 <code>snapshot</code> 是上一个生命周期函数的 <code>return</code> 值。</li></ul></li></ol><p><strong>注：在更新的生命周期函数里面要警惕使用 <code>this.setState</code>，如果使用一定要注意出口，否则会造成死循环。</strong></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li><code>componentWillUnmont()</code> 组件卸载前<ul><li>通常都是在这里面清除监听之类，以免造成对其他组件的影响。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础</title>
      <link href="/2018/08/17/React%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/17/React%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><blockquote><p>React 是 Fackbook 当初不满意市面上的 MVC 框架而自主开发的一款 JS 库。严格来说 React 是 V 层。</p><ul><li>轻量级视图库</li><li>虚拟DOM</li><li>组件系统</li><li>单项数据流</li><li>JSX语法</li></ul><p>注：React 中没有指令系统</p></blockquote><h2 id="React-使用"><a href="#React-使用" class="headerlink" title="React 使用"></a>React 使用</h2><ul><li><p>CDN 引入</p><ol><li><p>React 核心内容</p></li><li><p>React-dom 渲染真实 dom 的库</p></li><li><p>babel 编译 JSX 语法</p></li></ol></li><li><p>自己搭建 webpack</p></li><li><p>使用第三方或者官方的脚手架 <code>npx create-react-app &lt;name&gt;</code></p><h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2></li></ul><ol><li>单个根元素</li><li>单标签一定要闭合</li><li>img 标签的 alt 属性一定要有</li><li>标签是小写字母，组件首字母大写</li><li>class -&gt; className</li><li>label 标签不能使用for ，换成 htmlFor</li><li>注释：使用 JS 的注释，并且使用 { } ，例如 <code>{ /* &lt;P&gt; &lt;/P&gt;*/ }</code></li><li>style 需要写在对象当中<h2 id="JSX-的差值表达式"><a href="#JSX-的差值表达式" class="headerlink" title="JSX 的差值表达式"></a>JSX 的差值表达式</h2>如何在 JSX 中使用变量？</li></ol><blockquote><p>通过 { 变量 } 的差值表达式来使用变量。</p></blockquote><ul><li>差值表达式中能使简单的单个表达式，不能是语句也不能是条件或者循环语句，可以使用三目运算符。</li><li>如果想渲染字符串 <code>str = &#39;&lt;h1&gt;qqq&lt;/h1&gt;&#39;</code> ，需要在标签添加属性 <code>dangerouslySetInnerHTML</code> 接受一个对象的 <code>value{__html: str}</code>。</li><li>如果要传递参数到标签属性使用 <code>title = {msg}</code>。</li><li><code>{ null } | { undefined } | { ‘’ } | { false }</code>没有内容，不会在页面上渲染任何东西。</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><blockquote><p>react 没有全局组件的概念，使用哪个组件引入使用<br>组件的函数名直接拿去当标签名<br>React 中组件一共分两种：</p></blockquote><ol><li><p>函数式组件</p></li><li><p>类组件</p><h4 id="函数组件的定义："><a href="#函数组件的定义：" class="headerlink" title="函数组件的定义："></a>函数组件的定义：</h4></li><li><p>定义一个函数，然后 return 出来一段 JSX 语法。</p></li><li><p>函数名字就是组件的名字，首字母大写。</p><h4 id="类定义的组件："><a href="#类定义的组件：" class="headerlink" title="类定义的组件："></a>类定义的组件：</h4></li><li><p>定义一个类，类名就是组件名 首字母大写。</p></li><li><p>这个类需要继承于 <code>React.Component</code> 或者 <code>React.PureComponent</code>  基础组件。</p></li><li><p>类中的 render 函数是必须的，render函数的 return 出来的是一段 JSX 语法。</p></li></ol><p>注：组件的模板内容，如果需要换行去写的话，那么请使用（）包裹起来</p><p>没有使用 React，为什么还要去引入?</p><blockquote><p>JSX 语法是一个语法糖，经过 babel 转换，由于转换出来的代码中使用了 React，所以 React 必须要引入。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; JSX 语法糖</span><br><span class="line">React.createElement(&#39;div&#39;, &#39;参数&#39;, &#39;content&#39;);</span><br></pre></td></tr></table></figure><h2 id="组件的-props-属性"><a href="#组件的-props-属性" class="headerlink" title="组件的 props 属性"></a>组件的 props 属性</h2><ul><li>props 是个集合， prop 是具体的某一个</li><li>Vue 中使用 props 首先需要在组件中定义 props 的选项，而 React 中不需要。</li><li>函数组件中所有的 prop 会作为参数传递过来 </li><li>类组件所有的 prop 会在 <code>this.props</code> 身上</li></ul><h3 id="prop-types-校验"><a href="#prop-types-校验" class="headerlink" title="prop-types 校验"></a>prop-types 校验</h3><ol><li>安装 prop-types 的模板 <code>npm i --save-dev prop-types</code></li><li>引入 prop-types</li><li>设置组件的 propTypes 属性</li></ol><hr><p>React 元素 | 虚拟 DOM 元素 | JSX 代码中任意标签 | 通过 React.createElement 创建出来的 JS 对象</p><blockquote><p>最基本的单元，任何的标签都可以看成是一个 React 元素<br>如何区分 React 元素 与 React 组件的概念<br>组件就是一系列 React 元素的组成<br>什么是元素变量<br>定义一个变量，变量的值是 React 元素<br>React 元素 不是一个可变的对象</p></blockquote><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>数据绑定的方式有两种</p><ol><li>props</li><li>state    私有属性<h3 id="有状态组件-amp-无状态组件"><a href="#有状态组件-amp-无状态组件" class="headerlink" title="有状态组件 &amp; 无状态组件"></a>有状态组件 &amp; 无状态组件</h3><blockquote><p>组件有没有状态，主要看这个组件有没有 state，一般类组件就可以称为有状态组件，函数组件叫无状态组件</p></blockquote><h3 id="实现自动跟新，需要让组件有state，当-state-发生变化，他就会重新渲染"><a href="#实现自动跟新，需要让组件有state，当-state-发生变化，他就会重新渲染" class="headerlink" title="实现自动跟新，需要让组件有state，当 state 发生变化，他就会重新渲染"></a>实现自动跟新，需要让组件有state，当 state 发生变化，他就会重新渲染</h3></li></ol><ul><li>组件变化方式<ol><li>组件接收到的 props 发生改变</li><li>组件自身的 state 有了变化</li></ol></li></ul><p>defaultValue / defaultChecked默认值  ，单独使用 Value 会报错需要配合onChange使用</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>挂载</p><ul><li><p>constructor 构造函数 组件实例化的时候触发，不能在里面 setState。</p><ol><li>调用父类的构造函数 </li><li>super(props) 初始化数据 </li><li>绑定this指向</li></ol></li><li><p>componentWillMount()  × 即将过期</p></li><li><p>static getDerivedStateFromProps()  不常用，能够根据 props 的数据来设置新的 state 数据。</p><ol><li>初始化 render 之前调用一次</li><li>后续数据有变化，重新 render 之前又会调用</li><li>不要使用 <code>this.setState</code> -&gt; 哪些不能用？</li><li>需要有 return { } | null ，如果是对象，会将 state 合并</li></ol></li><li><p>render () 渲染  默认进来一次，后续如果有更新会再次触发 使用  setState 需要谨慎。</p></li><li><p>componentDidMount() 组件挂载完成。 </p><ol><li>获取异步数据</li><li>操作 dom</li></ol></li></ul><p>更新</p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate(nextProps, nextState) 性能优化，这个组件是否需要进行更新渲染？推荐使用 PureComponent 组件继承，两者不能同时存在。需要返回值，返回 true -&gt; 更新生命周期继续执行。false -&gt; 生命周期不执行。</li><li>render</li><li>getSnapshotBeforeUpdate(prevProps, prevState)   真实 DOM 渲染完成的前一刻</li><li>componentDidUpdate(<em>prevProps</em>, <em>prevState</em>, <em>snapshot</em>)  更新完成，对 DOM 进行操作，发送网络请求，但是需要正确进行 if 判断。</li></ul><p>卸载</p><ul><li>componentWillUnmount  销毁</li></ul><h2 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h2><h3 id="父-gt-子"><a href="#父-gt-子" class="headerlink" title="父 -&gt; 子"></a>父 -&gt; 子</h3><ul><li>通过props</li></ul><h3 id="子-gt-父"><a href="#子-gt-父" class="headerlink" title="子 -&gt; 父"></a>子 -&gt; 父</h3><ul><li>传递方法给子组件，然后子组件调用传递参数</li></ul><h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><ul><li><p>状态提升</p></li><li><p>第三方中央事件管理器(pubsub)</p></li><li><p>context</p><ol><li><code>let MyContext = React.createContext()</code> 创建出一个 context</li><li><code>MyContext.Prvider</code> 供应商组件</li><li><code>MyContext.Consumer</code> 消费者组件  标签中间需要使用函数返回 JSX，这个函数接受一个参数，这个参数就是供应商中的值。</li></ol><hr><ol><li>使用上面的步骤</li><li>不使用消费者组件，弄成 <code>x.contextType = MyContext</code>。使用 <code>this.context</code> 获取供应商的数据。</li></ol></li><li><p>React 状态管理器</p><ul><li><p>官方 flux</p></li><li><p>第三方  Redux</p><ol><li><p>任何时刻 state 都没有被改变。</p></li><li><p>生成一个新的 state 去替换旧的 state，Reducers 不能修改，只能通过 return 纯函数。</p><p>Tips：纯函数–任何时候都不会修改参数，有相同的入参，一定会产生相同的出参。</p></li></ol></li><li><p>第三方  </p></li></ul></li></ul><p>Tips：children 类似于 Vue 的插槽</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2018/07/06/Vuex/"/>
      <url>/2018/07/06/Vuex/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p><p>注意：他是一个状态管路模式，切记不要当做数据库使用</p></blockquote><h2 id="什么时候用vuex"><a href="#什么时候用vuex" class="headerlink" title="什么时候用vuex"></a>什么时候用vuex</h2><blockquote><p>用于组件通信，通常在使用了路由之后，不同组件之间的通信， 或者组件之间通信很复杂的时候，这个时候 Vuex 就能帮你进行这个操作。</p></blockquote><h2 id="Vuex的操作流程"><a href="#Vuex的操作流程" class="headerlink" title="Vuex的操作流程"></a>Vuex的操作流程</h2><ol><li>仓库，项目中组件上需要共享的数据放到仓库 state。</li><li>组件要使用仓库中state的数据，就从仓库里面</li><li>修改仓库中的state<ol><li>commit  mutation</li><li>派发 action -&gt; commit mutation</li></ol></li><li>仓库中state数据发生变化，组件就会得到更新</li></ol><h2 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h2><ol><li>安装vuex npm i –save vuex</li><li>src/store/index.js配置实例对象</li><li>main.js vue实例中配置store选项 选项的值就是 2 中的实例对象</li></ol><h2 id="Vue-router-实例的对象"><a href="#Vue-router-实例的对象" class="headerlink" title="Vue-router 实例的对象"></a>Vue-router 实例的对象</h2><ul><li><p>state：数据存放</p></li><li><p>mutations：修改 state 数据的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    setOne (state, params)&#123;<span class="comment">//第一个参数为本地state，第二个为传入的参数，传入多个数据使用数组或者对象</span></span><br><span class="line">        state.num = params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>modules：模块</p></li><li><p>getters：类似于计算属性，参数为 state</p></li><li><p>actions：异步操作，传入参数需要使用结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">   getCityList (&#123; state, commit &#125;) &#123;<span class="comment">//comit为mutation方法执行</span></span><br><span class="line">     axios.get(<span class="string">'地址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="将仓库中的数据拿到组件中使用"><a href="#将仓库中的数据拿到组件中使用" class="headerlink" title="将仓库中的数据拿到组件中使用"></a>将仓库中的数据拿到组件中使用</h2><ul><li><code>this.$store</code> 就是仓库的实例对象  直接使用不推荐</li><li>通过计算属性 computed</li><li>vuex提供的辅助函数 <code>mapState(&#39;仓库名&#39;,[&#39;state&#39;])</code>  key要和仓库中的相同</li></ul><p>为了能够将 mapstate 和自身的 computed 结合 ，推荐使用下面这种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">    ...mapState(<span class="string">'demo'</span>, [<span class="string">'demoState'</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">'demo'</span>, [<span class="string">'demoState'</span>]),</span><br><span class="line">    ...mapMutations(<span class="string">'demo'</span>, [<span class="string">'setCurFilmType'</span>]),</span><br><span class="line">    fn () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'自定义fn'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改仓库中的数据"><a href="#修改仓库中的数据" class="headerlink" title="修改仓库中的数据"></a>修改仓库中的数据</h2><ol><li>定义 <code>mutation</code> ，唯一一个可以修改 <code>state</code> 中数据的方法</li><li>组件中提交 这个 <code>mutatiion</code><ol><li><code>this.$strore.commit(&#39;mutatiion名字&#39;，参数)</code></li><li><code>this.$store.commit({type: mutaion 名字其他参数})</code></li><li>使用 <code>mapMutation</code> 辅助函数<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3></li></ol></li></ol><blockquote><p><code>mutation</code> 不允许异步代码，当你在 <code>mutation</code> 中使用异步函数的时候会出现数据刷新不及时。</p><p>例如：你设置了一个点击发送请求，获取服务器传递进来的数据。当你点击了按钮，发送请求，并且可能在页面上也渲染出来了，但是你点击 <code>Vue</code> 工具就会发现数据没有改变，再次点击数据是上一次发送请求传回来的数据。有时候你需要对数据进行判断操作的时候，使用 <code>mutation</code> 发送请求就会出现错误。</p></blockquote><h3 id="actions-写异步代码"><a href="#actions-写异步代码" class="headerlink" title="actions 写异步代码"></a>actions 写异步代码</h3><blockquote><p>每一个action里面都可以写异步代码，但是不能修改state里面数据，修改数据的还是 <code>mutaction</code></p></blockquote><h3 id="推荐在-vuex-moduels-每个模块都加上命名空间"><a href="#推荐在-vuex-moduels-每个模块都加上命名空间" class="headerlink" title="推荐在 vuex moduels 每个模块都加上命名空间"></a>推荐在 vuex moduels 每个模块都加上命名空间</h3><ol><li>操作方便</li><li>便于模块分类</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue CLI</title>
      <link href="/2018/07/03/vue-%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/07/03/vue-%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-CLI-简单的小案例"><a href="#Vue-CLI-简单的小案例" class="headerlink" title="Vue CLI 简单的小案例"></a>Vue CLI 简单的小案例</h1><blockquote><p>Vue CLI 也叫做脚手架工具，前端中一定会用到打包工具 webpakck 但是繁琐的配置问题让人十分头疼，但是 Vue CLI 提供了很好的快速打包配置功能。有着丰富的官方插件，并且还有图形化的创建和管理 Vue 项目的用户界面，可以说真的是 webpack 手残党的福星。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><strong>Node 版本要求</strong></p><p>Vue CLI 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a> 在同一台电脑中管理多个 Node 版本。</p></blockquote><p>使用以下命令行进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># 如果你是用的是 yarn</span></span><br><span class="line">yarn global add @add/cli</span><br></pre></td></tr></table></figure><p>如何测试自己是否安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h3><ol><li><p>通过以下命令创建一个 Vue 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure></li><li><p>选择一个配置的预设方案（回车确键认下一步）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.8.2</span><br><span class="line">? Please pick a preset:    <span class="comment"># 选择预设方案</span></span><br><span class="line">&gt; hello-config (less, babel, eslint)<span class="comment"># 我之前就配置好并且保存的，后面会遇到的。</span></span><br><span class="line">  default (babel, eslint)<span class="comment"># 默认设置 </span></span><br><span class="line">  Manually select features<span class="comment"># 手动选择，这里我们选择这个(你也可以使用默认设置)</span></span><br></pre></td></tr></table></figure></li><li><p>手动选择预设功能（空格键选择，<code>a</code>键全选）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.8.2</span><br><span class="line">? Please pick a preset: Manually select features<span class="comment"># 选择预设</span></span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;(*) Babel<span class="comment"># ES6 转 ES5 </span></span><br><span class="line"> ( ) TypeScript<span class="comment"># 支持 TypeScript</span></span><br><span class="line"> ( ) Progressive Web App (PWA) Support<span class="comment"># 支持 PWA 应用程序</span></span><br><span class="line"> ( ) Router<span class="comment"># 路由</span></span><br><span class="line"> ( ) Vuex<span class="comment"># Vue 程序开发的状态管理模式</span></span><br><span class="line"> (*) CSS Pre-processors<span class="comment"># CSS 预处理器 </span></span><br><span class="line"> (*) Linter / Formatter<span class="comment"># 规范化语法(魔鬼) </span></span><br><span class="line"> ( ) Unit Testing<span class="comment"># 单元测试</span></span><br><span class="line"> ( ) E2E Testing<span class="comment"># E2E 测试</span></span><br></pre></td></tr></table></figure></li><li><p>之后就是对相应的预设功能做一些选择，<code>eslint</code> 选择 <code>ESLint + Standard config</code> 标准设置，config 选择 <code>In dedicated config files</code>，也可以按照你自己的喜好来，这里只是我的设置。之后会提示你是否保存，保存为 xxx 预设名。</p></li></ol><h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><blockquote><p>通过 <code>vue ui</code> 的命令进入图形化页面创建和管理项目，具体步骤和上面差不多，而且是图形化很容易就不说了。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> demo </tag>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router</title>
      <link href="/2018/07/01/vue-router/"/>
      <url>/2018/07/01/vue-router/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><blockquote><p>创建单页应用，是非常简单的，<strong>这里的路由就是SPA（单页应用）的路径管理器。</strong></p></blockquote><h2 id="Vue-router-的使用"><a href="#Vue-router-的使用" class="headerlink" title="Vue-router 的使用"></a>Vue-router 的使用</h2><ol><li><p>安装 <code>npm i vue-router</code>。</p></li><li><p>在 <code>src</code> 目录下创建 <code>router</code> 文件夹，并创建 <code>index.js</code> 对其进行路由的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span><span class="comment">//引入vue-router模块</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;<span class="comment">//实例化路由对象</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/index'</span>,<span class="comment">//路径匹配</span></span><br><span class="line">            component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/index.vue'</span>)<span class="comment">//懒加载，组件位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router<span class="comment">//暴露</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在 <code>main.js</code> 中引入并且加入 Vue 实例中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>使用组件 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>，通过这个组件可以嵌套路由。</li></ol><h2 id="router-link-和-router-view"><a href="#router-link-和-router-view" class="headerlink" title="router-link 和 router-view"></a>router-link 和 router-view</h2><blockquote><p><code>router-link</code> 是个全局组件，类似于 a标签。to 属性：hash地址，类似于 a 标签的 <code>href</code>。</p><p><code>router-view</code> 路由嵌套。</p></blockquote><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><blockquote><p>使用了 <code>vue-router</code> 以后，在 vue 的实例中添加了 <code>$route</code> 和 <code>$router</code> 两个对象。</p><p><code>$route</code> ：当前匹配的路由对象信息，可以获得跳转来自、目的路径、参数等信息传递<br><code>$router</code> ： 路由器的实例对象，可以进行编程式导航。</p></blockquote><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><blockquote><p>简单的来说，就是通过 JS 代码进行跳转。</p></blockquote><h3 id="使用-router-对象调用方法进行导航"><a href="#使用-router-对象调用方法进行导航" class="headerlink" title="使用 $router 对象调用方法进行导航"></a>使用 <code>$router</code> 对象调用方法进行导航</h3><ul><li><p>push()    跳转页面 新增一个历史记录，该方法接受参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.push(<span class="string">'index'</span>)<span class="comment">//router中配置的name</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'index'</span> &#125;)</span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'index'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)</span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'index'</span>, <span class="attr">query</span>: &#123; <span class="attr">userId</span>: <span class="string">'123'</span> &#125;&#125;)<span class="comment">// 带查询参数，变成 /index?userId=123</span></span><br></pre></td></tr></table></figure></li><li><p>back()    后退</p></li><li><p>forward()    前进</p></li><li><p>go()    根据参数前进还是后退，正数前进，负数后退</p></li><li><p>replace()    跳转页面 重定向页面 不加历史记录，使用方法和 push 方法相同，通常使用在登录之类</p></li></ul><p><strong>注：name 和 params 搭配 相当于 POST 请求，参数需要通过 $route 获取，name 不能和path使用，path和query搭配 相当于 GET 请求。</strong></p><h1 id="路由的两种模式"><a href="#路由的两种模式" class="headerlink" title="路由的两种模式"></a>路由的两种模式</h1><blockquote><p><code>router</code> 下的 <code>index.js</code> 中的 <code>router</code> 实例中添加 <code>model: &#39;history&#39;</code></p></blockquote><ul><li><p>hash 默认模式</p><p>使用 URL 的 hash 来模拟完整的 URL ，所以当 URL 发生改变的时候，页面不会重新加载，也不会 404 报错，就是外观上略丑。</p></li><li><p>histroy 模式<br>利用了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，模拟出真实的 URL 路径，但是一刷新就会 404 报错，因为重新请求这个 URL 对应的地址是不存在的，所以需要后台配置相关的路由处理。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li></ul><ol><li>hash模式会在 URL 地址上会有一个 # 号，histroy 没有。</li><li>原理上，hash通过 <code>window.onHashChage</code>  这个事件来处理，histroy 基于 HTML5 中 histroy 新增的一些 `api. histroy.pushState(),api.histroy.replaceState(),window.onpoopstat 。</li><li>histroy 需要后台配合处理上线的 404 问题。<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1></li></ol><blockquote><p>当我们路由发生改变的时候，可以通过导航守卫做我们想做的。</p></blockquote><ul><li><p>全局守卫</p><ul><li><p>全局前置  <code>beforeEach()</code> 接收三个参数<br>  to    要去的路由<br>  from    来自哪个路由<br>  next    是否执行 ‘to’ ，直接调用那就相当于放行，如果传递一个false，那么就不放行，不调用不放行，调用并且里面可以传递路由的path路径或者是路由的对象信息，那么就可以重定向我们的参数中所指定的位置。</p></li><li><p>全局解析守卫 <code>beforeResolve</code></p></li><li><p>全局后置   <code>afterEach()</code><br>没有 <code>next</code> 参数</p></li></ul></li><li><p>路由独享</p><pre><code>`beforeRouteEnter`：进入当前组件，**不能访问this，因为此时组件还没被创建**`beforeRouteUpdate`：当前组件更新`beforeRouteLeave`：离开当前组件</code></pre></li><li><p>组件级别</p><h3 id="导航守卫的钩子函数"><a href="#导航守卫的钩子函数" class="headerlink" title="导航守卫的钩子函数"></a>导航守卫的钩子函数</h3></li></ul><blockquote><p>路由发生变化时候主动触发的一些函数</p></blockquote><h3 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h3><ol><li><code>beforeEach,afterEach</code> 实现页面进度条</li><li>登录拦截</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件</title>
      <link href="/2018/06/29/Vue-%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/06/29/Vue-%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h1><blockquote><p>组件是 vue.js 最强大，也是最重要的功能之一。组件可以拓展 HTML 元素，并且对其进行封装重用的代码，提高代码的复用性。所有的 vue 组件同时也都是 vue 的实例。</p></blockquote><h2 id="怎么去注册组件？"><a href="#怎么去注册组件？" class="headerlink" title="怎么去注册组件？"></a>怎么去注册组件？</h2><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><ul><li><p>全局注册组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'组件名'</span>,&#123;<span class="string">'选项对象'</span>&#125;)</span><br></pre></td></tr></table></figure><p>组件对象是相当于 HTML 中的标签中使用，特别注意以下两点：</p><ol><li>全局注册的组件需要在 Vue 所在挂载点的实例之前，否则会出现组件未注册的报错。</li><li>组件可以认为是 vue 的实例，但是选项对象中不能使用 <code>el</code> 和 <code>propsData</code></li></ol></li><li><p>局部注册组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'组件名'</span>: &#123;</span><br><span class="line">            <span class="string">'选项对象'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册的可以在同一个 vue 实例中创建多个组件</p></li></ul><h3 id="组件的选项对象"><a href="#组件的选项对象" class="headerlink" title="组件的选项对象"></a>组件的选项对象</h3><blockquote><p>组件的选项对象中一定要有 <code>template</code> ，因为这是渲染到页面中的模板。组件可以认为是 vue 的实例，但是选项对象中不能使用 <code>el</code> 和 <code>propsData</code></p></blockquote><ul><li><p><code>template</code>  </p><p>组件的选项对象中需要用 <code>template:&quot;&lt;p&gt;组件&lt;/P&gt;&quot;</code> 选项去定义模板，而且可以使用模板字符串，但是有时候这种方法总显得很复杂，所以有几种方法供我们使用：</p><ol><li><p>直接使用 “ “ 或者 `` ，在模板字符串中你可以随意的换行，但是没有代码提示和高亮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`&lt;button&gt; 这是组件 &lt;/button&gt;`</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>利用 <code>template</code> 标签的特性，将组件里面 <code>template</code> 内容写在标签内，然后组件的 <code>template</code> 的值填 <code>template</code> 标签的 id 。<code>template: &#39;#template-box&#39;</code></p><p>Tips：<code>template</code> 标签不会被渲染出来，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"template-box"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span>组件的a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>注：`template` 标签内只能有一个根节点，如果你要使用多个标签，就需要用一个标签，如上面的 div 包裹住，否则会有 `Error compiling template` 报错，提示你只能有一个根节点。</code></pre><ul><li><p><code>data</code></p><p>在 vue 的实例中，<code>data</code> 选项可以直接使用，但是在组件中需要以函数的方式，并且使用· <code>return</code> 来返回数据对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-tag'</span>,&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">                msg: <span class="string">'这是组件的data中的msg'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">template:<span class="string">'&lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>  因为组件通常是循环使用的，然后如果你组件还是直接使用 <code>data:{ msg: &#39;msg&#39;}</code> 的方式的话，这里就有一个问题，这里的 <code>data</code> 是引用类型传参，你的多个 <code>my-tag</code> 组件都是指向同一个 <code>msg</code> ，当你只想修改其中一个的时候，这里就会造成全都被修改的问题，所以需要使用 <code>return</code> ，这样每次都是一个不同地址的数据对象。</p><ul><li><p><code>props</code></p><blockquote><p>这里涉及到了组件的嵌套，我们后面再提。现在需要知道的是父组件传数据给子组件时，子组件需要由 <code>props</code> 来获取，并且<strong><code>props</code> 中的数据不能被修改！</strong>准确来说是能被修改，但是会报错，所以要修改数据，就在父组件的<code>data</code> 去修改。</p></blockquote></li></ul><p>其他的对象选项和 vue 实例中基本相同</p><h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><blockquote><p>通过标签的形式去使用，将组件名当做标签名在挂载点内使用，标签内任何内容都会被 <code>component</code> 选项覆盖。</p><p><strong>注：如果组件名是 newBox 驼峰命名法，那么使用的时候标签名需要改成 <code>&lt;new-box&gt;&lt;/new-box&gt;</code>，标签也可以使用单标签哦，注意闭合。</strong></p><p>props 的驼峰命名法也会有这个问题，因为在 HTML 会把大写字符解释为小写，如果使用字符串模板就不会有这个问题。所以在父组件传递参数给子组件时候需要在 HTML 内容中写例： <code>&lt;com-one :p-msg=&quot;msg&quot;&gt;&lt;/com-one&gt;</code>，但是在子组件的 <code>props</code> 中是 <code>props:[&#39;pMsg&#39;]</code>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">new-box</span>&gt;</span><span class="tag">&lt;/<span class="name">new-box</span>&gt;</span>//自定义组件</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h2><blockquote><p>在某些时候，我们需要对组件进行一个嵌套，而 vue 的组件嵌套时很简单，只需要在父组件中添加子组件标签即可。</p><p>这个例子涉及到了组件通信的问题，不要慌，继续往下看。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">child</span> <span class="attr">:app-msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">     &#123;&#123; msg &#125;&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">             msg: <span class="string">'父组件的msg'</span></span></span><br><span class="line">         &#125;,</span><br><span class="line">         components: &#123;</span><br><span class="line">             child: &#123;</span><br><span class="line">                 data() &#123;</span><br><span class="line"><span class="actionscript">                     <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                         msg: <span class="string">'子组件的msg'</span>,</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;,</span><br><span class="line"><span class="actionscript">                 props: [<span class="string">'appMsg'</span>],                   </span></span><br><span class="line"><span class="handlebars"><span class="xml">                 template: '<span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"> ----- 这是子组件的P标签----- </span><span class="template-variable">&#123;&#123; appMsg &#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span></span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行结果为：<code>子组件的msg ----- 这是子组件的P标签-----父组件的msg</code></p><p><strong>注意：不要踩命名的坑，之前说到当你 <code>template</code> 不是模板字符串的方式的时候，你需要注意标签名是横杠连接写法（这里讲的俗点）。但是还需要注意的一个点就是在 <code>:app-msg=&#39;msg&#39;</code> ，尽量注意，如果你使用驼峰命名法子组件使用时候接受的也是全小写！你使用的是 - 连接时候，使用的时候就需要是 驼峰式。我也是晕的很，这个还是自己要注意，并且多多实践。模板字符串一劳永逸呀。</strong></p><p>PS：自定义事件用<code>kebab-case</code>（- 链接）, 自定义属性用<code>camelCased</code>（驼峰式）</p><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><blockquote><p>有时候我们可能会碰到一些情况，就是子组件要获取或者修改父组件中的数据，又或者是父组件去访问子组件中的数据。但是不能直接去访问，需要通过一些方法来实现。</p></blockquote><ul><li><code>ref</code> 在元素上添加 <code>ref=&#39; &#39;</code>，然后可以在组件中使用方法 <code>this.$refs</code> 获取到与其相关联的组件。（不推荐）</li></ul><h3 id="父组件传递数据给子组件"><a href="#父组件传递数据给子组件" class="headerlink" title="父组件传递数据给子组件"></a>父组件传递数据给子组件</h3><ol><li><p>在父组件中使用子组件的时候自定义一个指令，用于接受父组件传递的数据。</p><p>子模板中自定义指令 <code>app-msg</code> ，<code>msg</code> 是父组件 data 中的数据，需要对应名称！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>//父组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:app-msg</span>=<span class="string">"msg"</span> <span class="attr">ref</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span>//子组件</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>子组件中通过 <code>props</code>选项，子组件获取到父组件传递进来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> components: &#123;</span><br><span class="line">      child: &#123;</span><br><span class="line">    props: ['app-msg'],</span><br><span class="line">   template: '<span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span>  ----- 这是子组件的P标签-----&#123;&#123; appMsg &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h3><blockquote><p>这个方法也可以用作子组件去调用父组件的方法。</p></blockquote><ol><li><p>同样的，使用子组件的时候，自定义一个事件，父组件传递方法名给这个事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>  @<span class="attr">son-fn</span>=<span class="string">"fn"</span> &gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>子组件使用 <code>@click</code> 或其他事件触发，在事件中使用 <code>this.$emit</code> 去调用父组件中的事件，同时，这里可以传子组件的参数，实现子组件传递数据给父组件。</p><p>父组件中的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    fn(s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = s;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'父组件的fn方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   子组件通过自定义的事件获取到了父组件中的方法，在 <code>template</code> 使用 <code>@click</code>去调用：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sonMsg: <span class="string">'巴拉巴拉巴拉'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fnn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs);</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'son-fn'</span>, <span class="keyword">this</span>.sonMsg);<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">props: [<span class="string">'app-msg'</span>],</span><br><span class="line">template: <span class="string">'&lt;p @click="fnn"&gt; ----- 这是子组件的P标签-----&#123;&#123; appMsg &#125;&#125; &lt;/p&gt;'</span></span><br></pre></td></tr></table></figure><p>   this.$emit` 参数是第一个为方法名称，这个是在 DOM 中自定义的方法名，后面为传入的参数。</p><h3 id="我的理解："><a href="#我的理解：" class="headerlink" title="我的理解："></a>我的理解：</h3><ul><li><p>首先是父组件传递数据给子组件，因为在 <code>&lt;div id=&quot;app&quot;&gt;</code> 标签中就是在父组件中，此时你可以传入任何父组件里面的数据，而子组件自定义的指令接受到了，相当于获取到了传递的值。</p></li><li><p>子组件传递父组件使用的可以认为是回调函数的一种方法，然后通过传入参数去把子组件的参数传递给父组件当中。具体看图：</p><p><img src="/medias/images/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.png" alt="父子组件通信"></p></li></ul><h2 id="兄弟组件以及复杂关系之间的通信"><a href="#兄弟组件以及复杂关系之间的通信" class="headerlink" title="兄弟组件以及复杂关系之间的通信"></a>兄弟组件以及复杂关系之间的通信</h2><h3 id="子传父，然后父传子"><a href="#子传父，然后父传子" class="headerlink" title="子传父，然后父传子"></a>子传父，然后父传子</h3><h3 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h3><h3 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h3><p>前两种在官方中很详细，所以这里重点简述一下中央事件总线，因为 <code>$on和$emit</code> 需要在同一公共的实例才能触发，所以我们可以创建一个 Vue 实例专门去放置事件</p><ol><li><p>创建中央 <code>var bus = new Vue()</code></p></li><li><p>在兄弟组件 A 中添加 <code>mounted</code>生命周期函数，挂载点挂载的时候自动开启监听，这里相当于把组件 A 的函数传递给 <code>bus</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">    bus.$on(<span class="string">'fn'</span>,(val)=&gt;&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = val;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在兄弟组件 B 中调用 <code>$emit(&#39;fn&#39;, this.name)</code>方法，并且传入组件 B 中的参数，实现兄弟组件或者复杂组件之间的通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">`&lt;div&gt;&lt;p&gt; &#123;&#123; name &#125;&#125; &lt;/p&gt;&lt;button @click="fnn"&gt;点我&lt;/button&gt;&lt;/div&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        fnn() &#123;</span><br><span class="line">            bus.$emit(<span class="string">'fn'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote><p>在组件的标签内容中，填写任何内容，都会被 <code>template</code> 模板内容所覆盖，但是有时候我们需要的确实另外的效果，希望标签内的内容能够被保留，这时候就需要用到插槽。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">这是插槽内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>template</code> 中添加 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签，组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 就会被替换成 “这是插槽内容”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">"&lt;div&gt; &lt;p&gt;这是一个p&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;"</span></span><br></pre></td></tr></table></figure><p>并且，在模板内容中的 <code>slot</code> 标签中你可以添加任意 HTML 元素，甚至是其他组件，模板标签内的内容就叫做后备内容。当你组件中没有写任何内容的时候，就会渲染出这些内容，可以理解为备用内容。新语法中 <code>template</code> 才可以使用 <code>v-slot</code> 。</p><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><blockquote><p>当你想在插槽中使用数据的时候，你可以要注意到此时的编译作用域问题。</p><p><strong>官方提示：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span>你们慢慢木<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">           data () &#123;</span><br><span class="line">               <span class="keyword">return</span> &#123;</span><br><span class="line">                   msg: <span class="string">'666'</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           template: <span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;slot name="up"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">               &lt;button&gt;123&lt;/button&gt;</span></span><br><span class="line"><span class="string">               &lt;slot name="down"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">               &lt;slot&gt;&#123;&#123; msg &#125;&#125;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">           `</span></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>这个时候因为 msg 的使用是在子组件的 <code>template</code>中调用编译的，所以就是子组件中的 msg。相反，如果你在 <code>div#app</code> 标签中使用 <code></code> 那么编译的就是父组件中的 msg，这一点很重要，可以参考父组件向子组件传递数据，子组件通过自定义指令接受，自定义指令的等号后面就是父组件的内容。</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote><p>顾名思义，这是一个有着具体名称的插槽，可以认为是有钥匙和锁对应的插槽。</p><p>在正常情况下，插槽内容都会被加入到插槽模板标签中，也称为默认插槽。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-slot:cha</span>&gt;</span>你们慢慢木<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span> &gt;</span>巴拉巴拉的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时的第一个 P 标签就被上锁了，在子组件的模板内容中直接使用 <code>slot</code> 是获取不到的，因为你没有钥匙，钥匙就是在 <code>slot</code> 标签上面添加 <code>name=&quot;cha&quot;</code>，对应插槽内容中，这就叫做具名插槽。</p><h2 id="非-props-特性"><a href="#非-props-特性" class="headerlink" title="非 props 特性"></a>非 props 特性</h2><blockquote><p>什么是 props ？</p><p>当父组件向子组件传递数据的时候，子组件需要使用 <code>props</code> 选项去接收传递过来的数据，但是如果父组件传递下来，但是子组件并没有使用 <code>props</code> 去接收，那么这些传递过来的属性就会有一些特性。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:age</span>=<span class="string">"age"</span> <span class="attr">:name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">    <span class="comment">// inheritAttrs:false,//非props特性不让你覆盖  </span></span><br><span class="line">    template: <span class="string">`&lt;div  name='qqq'&gt;</span></span><br><span class="line"><span class="string">                  &lt;p&gt; &#123;&#123; msg &#125;&#125; &#123;&#123; $attrs &#125;&#125; &lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;/div&gt; `</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        age: &#123;</span><br><span class="line">            type: <span class="built_in">String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">'这是个 msg '</span>,</span><br><span class="line">            name: <span class="string">'lemon'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是个 msg &#123; <span class="string">"name"</span>: <span class="string">"qfl"</span> &#125;   <span class="comment">-----输出的结果</span></span><br></pre></td></tr></table></figure><p>此时的 name 就是非 props 特性：</p><ul><li><p>能够被 <code>$attrs</code> 获取到</p></li><li><p>非props特性自动写入根元素上覆盖，渲染出来的子组件标签上面的 <code>name</code>不是 qqq ，而是传递过来的父组件中的 name 值</p><p>非 props 特性会覆盖子组件模板 <code>template</code>上面相同的值。</p><p><strong>注：<code>class</code> 和 <code>style</code> 两大流氓不受影响，会合并。</strong></p></li><li><p>通过 <code>inheritAttrs:false</code>选项可以拦截不让 name 覆盖，但是还是能被 <code>$attrs</code>，这里是不受影响的。</p></li></ul><h3 id="能做些什么呢-？"><a href="#能做些什么呢-？" class="headerlink" title="能做些什么呢 ？"></a>能做些什么呢 ？</h3><blockquote><p>当我们不想传递到子组件的根元素使用，而是想子元素使用这些属性的时候，并且属性较多，我们不想一个一个在 <code>data</code> 中去 return ，繁琐而且容易遗漏出错。</p><p><code>inheritAttrs:false</code>和 <code>$attrs</code> 可以实现让子组件模板里的子标签能够使用。在需要使用的地方，比如上面的子组件的 P 标签中，我们不需要一个个去写，直接 <code>v-bind=&quot;@attrs&quot;</code>，注意这里不能简写成 ：。</p><p>注意： <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="BUS-的原理是什么？"><a href="#BUS-的原理是什么？" class="headerlink" title="BUS 的原理是什么？"></a>BUS 的原理是什么？</h3><blockquote><p>我的理解就是，通过中央事件管理器存放监听的方法，然后执行的时候再到这里来调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = &#123;&#125;;<span class="comment">//存放各种方法</span></span><br><span class="line"><span class="keyword">var</span> bus = &#123;<span class="comment">//中央处理</span></span><br><span class="line">    $on: <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fun[eventName])&#123;<span class="comment">//不存在创建</span></span><br><span class="line">            fun[eventName] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        fun[eventName].push(callback);</span><br><span class="line">    &#125;,  </span><br><span class="line">    $emit: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, params</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fun[eventName])&#123;<span class="comment">//存在方法</span></span><br><span class="line">            fun[eventName].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">                cb(params);<span class="comment">//</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-model-的原理是怎样的呢？"><a href="#v-model-的原理是怎样的呢？" class="headerlink" title="v-model 的原理是怎样的呢？"></a>v-model 的原理是怎样的呢？</h3><blockquote><p>首先是通过 <code>:value=&quot;value&quot;</code> 指令获取到 data 中的 value 值，实现单向的 value 绑定输入框内容显示。然后再通过事件 <code>@input=&quot;value=$evnet.target.value&quot;</code> 当你输入值，调用事件修改 data 中的 value 值实现双向绑定。这里需要注意的是单选框和复选框用的是 <code>@change</code>。</p></blockquote><h3 id="修饰符-sync-语法糖的原理"><a href="#修饰符-sync-语法糖的原理" class="headerlink" title="修饰符 sync 语法糖的原理"></a>修饰符 sync 语法糖的原理</h3><h3 id="内置组件有哪些？"><a href="#内置组件有哪些？" class="headerlink" title="内置组件有哪些？"></a>内置组件有哪些？</h3><blockquote><p><code>component</code></p><p><code>template</code></p><p><code>slot</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础知识2</title>
      <link href="/2018/06/28/vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"/>
      <url>/2018/06/28/vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h2><blockquote><p>当有时候我们需要绑定 class 或者是动态切换 class 的时候，我们可以通过 <code>v-bind:class</code> 来实现。</p></blockquote><h3 id="class-绑定"><a href="#class-绑定" class="headerlink" title="class 绑定"></a>class 绑定</h3><p>语法：<code>:class=&#39;{ 类名: 条件 }&#39;</code>  – 这里的条件可以是表达式，也可以是 data 的数据，但是结果需要是 booleran。可以使用多组判断条件，使其能够实现不同条件有不同的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; 'box': isHave , 'box1': isOk&#125;"</span>&gt;</span> 这是一个bbbox<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是一个bbbox33<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">           el: <span class="string">'#box'</span>,</span></span><br><span class="line">           data: &#123;</span><br><span class="line"><span class="actionscript">               isHave: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">               isOk: <span class="literal">true</span></span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="绑定到内联样式"><a href="#绑定到内联样式" class="headerlink" title="绑定到内联样式"></a>绑定到内联样式</h3><p>直接将 <code>：style</code> 绑定一个对象，里面是 css 样式，这是最简洁明了的。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在监听事件的时候，我们可能需要一些特殊的处理，比如去掉默认行为，或者是禁止事件冒泡，vue 为我们提供了很简便的方法，指令后面添加事件修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'box'</span> @<span class="attr">click.prevent</span>=<span class="string">'fn'</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>.stop</code>    阻止事件冒泡</li><li><code>.prevent</code>    阻止默认行为</li><li><code>.capture</code>    事件捕获</li><li><code>.self</code>         事件由自身触发  参考 <code>onmouseout</code> 和 <code>onmouseleave</code></li><li><code>.once</code>    单次事件</li><li><code>.passive</code>    默认行为，这个就有点特别了，因为如果每次事件产生，浏览器都会去查询是否有 <code>preventDefault</code> 阻止该次事件的默认动作，使用它是为了告诉浏览器，不用查询了，我告诉你没有阻止默认动作。通常用在高频率事件中，比如滚动监听、鼠标移动，因为 1px 都会有事件产生，这样就能减少大量的资源。</li></ul><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><blockquote><p>例：<code>@keyup.enter=&#39;submit&#39;</code></p><p>当你按回车时候提交表单</p><p>注：<code>Vue.config.keyCodes.abc = 222</code>    自定义按键</p></blockquote><p>同理还有鼠标按键修饰符，系统修饰键，异曲同工。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 基础知识1</title>
      <link href="/2018/06/27/Vue%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/"/>
      <url>/2018/06/27/Vue%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote><p>vue 是什么？</p><p>构建用户界面的渐进式框架    MVVM </p><p>原理：ObjectdefinePropety 修改属性的get，set方法，作为 vue 的核心，是通过 Observer,Dep,Watcher,Complie 四个类以及 CpompileUtil</p><p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">vue</a> 下载地址</p></blockquote><h2 id="Vue-基础语法"><a href="#Vue-基础语法" class="headerlink" title="Vue 基础语法"></a>Vue 基础语法</h2><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><ol><li><p>下载并且引入 Vue.js</p></li><li><p>实例化一个对象  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#box'</span>,<span class="comment">//挂载点  你需要操作的节点</span></span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">'hello vue'</span></span><br><span class="line">    &#125;,<span class="comment">//存放的数据</span></span><br><span class="line">    methods:&#123;<span class="comment">//绑定事件的函数存放处</span></span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>差值语法 <code></code>，可以是数据、 JS 表达式</p></li></ol><h3 id="dom元素内添加属性"><a href="#dom元素内添加属性" class="headerlink" title="dom元素内添加属性"></a>dom元素内添加属性</h3><ul><li><p>事件的绑定 <code>v-on:click = &#39;fn&#39;</code> 简写： <code>@click</code></p></li><li><p>属性的绑定 <code>v-bind:title = &#39;msg&#39;</code> 简写： <code>:title</code></p><blockquote><p>类似于 Jquery 的 attr 方法，例：你要绑定一个链接到百度，那么你可以使用 <code>:href = &#39;url&#39;</code>，然后在 Vue的实例对象中的 data 中添加 <code>url:&#39;http://www.baiducom&#39;</code></p></blockquote></li><li><p>双向绑定 <code>v-model = &#39;msg&#39;</code> \</p><blockquote><p>在挂载点中添加文本框，然后使用该绑定方法，那么 msg 的值会随着文本框的内容改变，反之，文本框的内容也会随着 msg 的值变化</p></blockquote></li><li><p>单次变化，默认绑定一次，后续数据更新不会重新改变 <code>v-once</code></p></li><li><p>解析 HTML ，使用 <code>v-html</code> =&gt; 尽量少用，防止 XSS 攻击</p></li></ul><h3 id="在-Vue-的实例中选项"><a href="#在-Vue-的实例中选项" class="headerlink" title="在 Vue 的实例中选项"></a>在 Vue 的实例中选项</h3><ul><li><p>el 对应的是 dom 节点 ， 还可以使用 vue 的实例对象.$mout() 设置挂载点</p></li><li><p>methods 绑定事件的方法存放处</p></li><li><p>data 存放的数据</p></li><li><p>computed  计算属性</p></li><li><p>watch 监听器   当你在控制台改变 data 中 msg 的时候，会执行该方法，打印出两个值，起到监听作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">msg: <span class="function"><span class="keyword">function</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newValue);</span><br><span class="line">        <span class="built_in">console</span>.log(oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Tips：v-cloak vue 定义的属性，能解决页面闪烁跳动的效果 </p><blockquote><p>在 css 样式中使用属性选择器来选定 v-clock 设置属性为 <code>display:none</code> </p></blockquote><h3 id="Vue常用指令-（通常以-v-开头，用在元素的标签上面，借鉴-angluar）"><a href="#Vue常用指令-（通常以-v-开头，用在元素的标签上面，借鉴-angluar）" class="headerlink" title="Vue常用指令  （通常以  v- 开头，用在元素的标签上面，借鉴 angluar）"></a>Vue常用指令  （通常以  v- 开头，用在元素的标签上面，借鉴 angluar）</h3><ul><li><p>v-if 类似于 JS 当中的判断，如果对应的属性为真时显示内容，为假时改节点都不会在 F12 中存在，控制 dom 的存在与否</p></li><li><p>v-show 和 v-if 也是能隐藏节点 但是他和 v-if 有不同的地方，首先 v-if 是通过删除和创建 dom 的方式，而 v-show 则是使用 <code>display:none</code> 控制消失和显示，控制 dom 的显示与否</p></li><li><p>v-for 循环一组数据来渲染 dom 结构</p><p>如果在 v-for 没有给循环的每一项设置一个唯一标识符，那么后续这个数据发生变化，页面重新渲染，浪费性能</p><p>注：在组件中，v-for 必须要有 key</p></li></ul><p>Tips：了解 v-bind:[attrname]  /  修饰符 . </p><h3 id="Vue-数据的检测"><a href="#Vue-数据的检测" class="headerlink" title="Vue 数据的检测"></a>Vue 数据的检测</h3><ul><li><p>数组：使用一些变异方法或者直接替换数据都能引起页面的更新。但是以下两个操作不会：</p><ol><li>直接根据数据下标来修改</li><li>直接修改数据的长度</li></ol><p>解决方法：使用 Vue.set 原型方法或者使用 vm.$set 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(target, index, value)；</span><br><span class="line">Vm.$<span class="keyword">set</span>(target, index, value)；</span><br></pre></td></tr></table></figure></li><li><p>对象：Vue 不能检测对象属性的添加或删除 ，添加解决方法同上 index 为 key 值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.delete(target,key);<span class="comment">//删除对象属性</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><h3 id="计算属性、方法、侦听属性都有什么区别？什么时候使用"><a href="#计算属性、方法、侦听属性都有什么区别？什么时候使用" class="headerlink" title="计算属性、方法、侦听属性都有什么区别？什么时候使用?"></a>计算属性、方法、侦听属性都有什么区别？什么时候使用?</h3><blockquote><p>计算属性存放在 computed ，方法在 methods ，侦听属性在 watched。当你使用 methods 使用函数的时候，无论数据是否改变，都会执行这个函数，computed 只会在 msg 发生变化才会被执行。当你执行异步操作或者运算开销较大时候可以使用watch</p></blockquote><h3 id="v-show-有着更高的首次渲染开销，v-if-有更高的切换开销。原因是什么呢？"><a href="#v-show-有着更高的首次渲染开销，v-if-有更高的切换开销。原因是什么呢？" class="headerlink" title="v-show 有着更高的首次渲染开销，v-if 有更高的切换开销。原因是什么呢？"></a>v-show 有着更高的首次渲染开销，v-if 有更高的切换开销。原因是什么呢？</h3><blockquote><p>因为 v-show 无论你是 true 还是 false 你都需要把 dom 结构给渲染出来，但是只需要渲染一次，因为之后的切换显示隐藏都是基于 css 属性 <code>display</code> 来执行的。</p><p>当你是 false 时候 v-if 执行，此时 dom 整个都不存在，渲染开销远大于 v-show，但是之后的切换每次都要重新添加 dom 进行渲染、删除等操作，十分消耗资源，所以频繁切换操作时候推荐使用 v-show</p></blockquote><h3 id="当使用条件渲染的时候，有时候会使页面出现布局变动，怎么解决呢？"><a href="#当使用条件渲染的时候，有时候会使页面出现布局变动，怎么解决呢？" class="headerlink" title="当使用条件渲染的时候，有时候会使页面出现布局变动，怎么解决呢？"></a>当使用条件渲染的时候，有时候会使页面出现布局变动，怎么解决呢？</h3><blockquote><p>通过将 vue 代码添加在 template 标签中，在浏览器中能够发现 条件渲染依旧能执行，但是这个标签并不会存留。正因为这个特点 template 不能和 v-show 搭配使用，因为这个标签不存留，所以不存在 <code>display</code> 的操作。</p></blockquote><h3 id="当你需循环判断某个对象的数据的时候，尽量不要使用-v-if-和-v-for-嵌套"><a href="#当你需循环判断某个对象的数据的时候，尽量不要使用-v-if-和-v-for-嵌套" class="headerlink" title="当你需循环判断某个对象的数据的时候，尽量不要使用 v-if 和 v-for 嵌套"></a>当你需循环判断某个对象的数据的时候，尽量不要使用 v-if 和 v-for 嵌套</h3><blockquote><p>因为这样做计算次数多，增加内容数据少的时候没什么区别，但是数据较为庞大的时候，就很明显了。这里推荐使用 <code>filter</code> 过滤，例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items.filter(item =&gt; item.isOk)"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tips：箭头函数的函数体部分如果没有花括号，且只有一条语句会自动return</p></blockquote><h3 id="v-text-、v-html-、差值表达式都有什么区别？"><a href="#v-text-、v-html-、差值表达式都有什么区别？" class="headerlink" title="v-text 、v-html 、差值表达式都有什么区别？"></a>v-text 、v-html 、差值表达式都有什么区别？</h3><blockquote><p>通常情况下，差值表达式的弊端是在网速较慢的情况下出现闪烁的问题，出现 <code></code> ，需要使用 <code>v-cloak</code> 可以解决这个问题。</p><p>v-text 和 v-html 会把标签内部所有元素都给覆盖，并且 v-html 能解析 msg 中的 HTML 标签</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express案例</title>
      <link href="/2018/05/22/express%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/05/22/express%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="通过-express-框架实现简单的小案例"><a href="#通过-express-框架实现简单的小案例" class="headerlink" title="通过 express 框架实现简单的小案例"></a>通过 express 框架实现简单的小案例</h1><h2 id="需要用到的工具"><a href="#需要用到的工具" class="headerlink" title="需要用到的工具"></a>需要用到的工具</h2><ul><li><p><a href="https://insomnia.rest/download/" target="_blank" rel="noopener">Insomnia</a>    模拟发送请求的工具</p></li><li><p><a href="https://robomongo.org/download" target="_blank" rel="noopener">Robo 3T</a>    操作 <a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">mongodb</a> 数据库的可视化工具(PS：安装数据库最后左下角不要勾选)</p></li><li><p>express 框架</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -<span class="literal">-save</span> express</span><br></pre></td></tr></table></figure></li><li><p>为了能够更好地浏览功能层次，我将文件夹的目录创建如下：</p><p><img src="/medias/images/path.png" alt="目录"></p></li></ul><h2 id="案例流程"><a href="#案例流程" class="headerlink" title="案例流程"></a>案例流程</h2><ol><li><p>创建server.js文件</p><ul><li><p>这里需要先了解<code>userRouter</code>和中间件</p></li><li><p>POST 请求的数据，将会在<code>req.body</code>中使用</p></li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)<span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express();<span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./routes/user'</span>);<span class="comment">//引入分离的路由文件</span></span><br><span class="line"><span class="comment">//中间件POST请求数据以JSON输出，否则会得到undefined</span></span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">false</span></span><br><span class="line">&#125;));</span><br><span class="line">app.use(<span class="string">'/api'</span>, userPouter);</span><br><span class="line">app.listen(<span class="number">4444</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务启动成功，请访问http://localhost:4444'</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>在 routes 文件夹中创建 user.js<ul><li>分离代码，使框架更加清晰，将回调函数存放在<code>controller/userCtrl</code></li><li>访问地址是<code>http://localhost:4444/api/reg/</code>进入注册页面</li><li>如果代码不暴露，即使调用了该文件，也不能直接调用内容方法</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> UserCtrl = <span class="built_in">require</span>(<span class="string">'../controller/userCtrl'</span>);</span><br><span class="line">router.post(<span class="string">'/reg'</span>, UserCtrl.reg);</span><br><span class="line"><span class="built_in">module</span>.exports = router<span class="comment">//暴露  用于server.js使用</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 controller 文件夹中创建 userCtrl.js<ul><li>主要是存放不同操作的回调函数</li><li>这里需要和数据库交互，所以要引入<code>model/user</code></li><li>bcrypt 是加密模块，用于加密用户密码 <code>npm i bcrypt</code></li><li>findOne 返回的是promise，所以使用then()，并且根据返回的数据，如果查询到该用户名在数据库中存在的话data不为空，报错给前端，结束注册请求</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserModel = <span class="built_in">require</span>(<span class="string">'../model/user'</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>);</span><br><span class="line"><span class="keyword">const</span> reg = <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;<span class="comment">//用户注册</span></span><br><span class="line">    <span class="keyword">let</span> name = req.body.username;<span class="comment">//获取用户名，和数据库进行对比</span></span><br><span class="line">    UserModel.findOne(&#123;<span class="comment">//mongodb数据库查询语句</span></span><br><span class="line">        username: name</span><br><span class="line">    &#125;).then(data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(data)&#123;</span><br><span class="line">            res.send(&#123;<span class="attr">code</span>: <span class="number">-1</span>, <span class="attr">msg</span>: <span class="string">'用户名存在，请更换用户名'</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象的assign方法来更新对象中的password数据</span></span><br><span class="line">     <span class="keyword">let</span> body = <span class="built_in">Object</span>.assign(&#123;&#125;, req.body, &#123;</span><br><span class="line">            <span class="comment">//密码进行哈希加密</span></span><br><span class="line">            password: bcrypt.hashSync(req.body.password, <span class="number">10</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> user = <span class="keyword">new</span> UserModel(body);<span class="comment">//实例化对象</span></span><br><span class="line">        user.save().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            res.send(&#123;<span class="attr">code</span>: <span class="number">0</span>, msg&#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err.message);</span><br><span class="line">            res.send(&#123;<span class="attr">code</span>: <span class="number">-1</span>,  <span class="attr">msg</span>: <span class="string">'注册失败'</span> &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>model/user.js</code>和<code>config/db.js</code> 分别是对进行表操作和数据库连接<ul><li>在<code>model/user.js</code>引入 db.js ，相当于在连接数据库基础上进行表的操作</li><li>因为某些原因，这里操作的是 user ，实际操作的是users表</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../config/db'</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> dbSchema(&#123;<span class="comment">//这里是表的字段名和要求</span></span><br><span class="line">    username: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span><span class="comment">//设置用户名为必填项</span></span><br><span class="line">    &#125;，</span><br><span class="line">    password: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span><span class="comment">//设置用户名为必填项</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = db.model(<span class="string">'user'</span>, schema);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://localhost:27017/apple'</span>;</span><br><span class="line">mongoose.connect(url, &#123;</span><br><span class="line">    useNewUrlParser: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库连接成功'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">consolelog(<span class="string">'数据库连接失败'</span>, error.message);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = mongoose;</span><br></pre></td></tr></table></figure><hr><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><ol><li><p>在终端中输入<code>nodemon server.js</code>启动服务</p></li><li><p>在 Insomnia 中进行 POST 请求<img src="/medias/images/POST.png" alt="POST"></p></li></ol><hr><p>Tips：一个简单的用户注册就完成了，用户登录以及修改等操作也可以照葫芦画瓢，最重要还是要了解流程</p><p><a href="https://github.com/One-Lemon/express-demo" target="_blank" rel="noopener">github案例仓库</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> demo </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 基础模块</title>
      <link href="/2018/04/20/node-js/"/>
      <url>/2018/04/20/node-js/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="node-运行-js文件（PS：安装好了node）"><a href="#node-运行-js文件（PS：安装好了node）" class="headerlink" title="node 运行 js文件（PS：安装好了node）"></a>node 运行 js文件（PS：安装好了node）</h2><ul><li>在vscode中随便写一段js代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mr的x的值为：'</span> + x);</span><br></pre></td></tr></table></figure><ul><li>在vscode中打开终端</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./mr.js</span><br></pre></td></tr></table></figure><h2 id="fs模块使用"><a href="#fs模块使用" class="headerlink" title="fs模块使用"></a>fs模块使用</h2><ol><li><p>在JS文件中先引入模块 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用模块中的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./test.txt'</span>, (err, data)=&gt;&#123;</span><br><span class="line">       <span class="keyword">if</span>(err)&#123;<span class="comment">//如果存在异常，报错</span></span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;<span class="comment">//正常执行输出内容</span></span><br><span class="line">           <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>bug1：cannot find module    注意路径</p></li><li><p>bug2：乱码    输出内容忘记添加toString方法</p></li></ul><h2 id="http模块的使用"><a href="#http模块的使用" class="headerlink" title="http模块的使用"></a>http模块的使用</h2></li><li><p>在JS文件中引入模块（这一步是万年不变的，）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建服务以及逻辑（server中可以更根据不同的需求进行逻辑判断）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);<span class="comment">//终端中打印出地址 favicon.icon忽略</span></span><br><span class="line">    res.write(<span class="string">'123456'</span>)；<span class="comment">//页面中输出</span></span><br><span class="line">    res.end()<span class="comment">//结束</span></span><br><span class="line">&#125;)</span><br><span class="line">server.lister(<span class="number">4242</span>);<span class="comment">//自定义端口号  开启服务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务已开启，请访问http://localhost:4242'</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="express模块"><a href="#express模块" class="headerlink" title="express模块"></a>express模块</h2><blockquote><p>高度包容、快速而极简的 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> Web 框架</p><p>在http模块中如果深入使用，你会发现许多得问题，例如get和post请求的不同，文件路径的改变。</p><p>监听文件变化，修改代码自动重启服务，降低重复操作</p></blockquote><ol><li><p>使用方法还是先引入模块（省略，参考上面）</p></li><li><p>实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br></pre></td></tr></table></figure></li><li><p>请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'/'</span>, (req, res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> _url = url.parse(req.url);<span class="comment">//需加入url模块</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问量+1'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(_url.query);<span class="comment">//获取到url中的参数</span></span><br><span class="line">    res.send(<span class="string">'hello node js'</span>);<span class="comment">//等价于res.write和res.end</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>部署静态文件托管</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/'</span>, express.static(path.resolve(__dirname,<span class="string">'./public'</span>)));</span><br><span class="line">app.listen(<span class="number">4242</span>);<span class="comment">//监听服务</span></span><br><span class="line"><span class="built_in">console</span>.lg(<span class="string">'服务开启，请访问http://localhost:4000'</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="输出结果（PS：参数是我在地址自己加的）"><a href="#输出结果（PS：参数是我在地址自己加的）" class="headerlink" title="输出结果（PS：参数是我在地址自己加的）"></a>输出结果（PS：参数是我在地址自己加的）</h3><p><img src="C:%5CUsers%5Clemon%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558355610640.png" alt="1558355610640"></p><h3 id="node-模块的时候基本都是异曲同工，需要的是能看懂API手册"><a href="#node-模块的时候基本都是异曲同工，需要的是能看懂API手册" class="headerlink" title="node 模块的时候基本都是异曲同工，需要的是能看懂API手册"></a>node 模块的时候基本都是异曲同工，需要的是能看懂API手册</h3><h2 id="思考：app-all和app-use有什么区别"><a href="#思考：app-all和app-use有什么区别" class="headerlink" title="思考：app.all和app.use有什么区别?"></a>思考：app.all和app.use有什么区别?</h2><blockquote><p>类似于app.METHOD的路由请求 。</p><p>参数：path    路径，callback    回调函数</p></blockquote><p>结合API文档以及实际操作得出的区别</p><ul><li><p>use通常是作为中间件使用的    例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/a'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问量+1'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时可以接受匹配到/a所有的请求 /a/b也可以。<img src="C:%5CUsers%5Clemon%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558357897282.png" alt="1558357897282"></p></li><li><p>all是以具体的路由    例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'/a'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问量+1'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以接受/a get ，/a post 等，但是不能路由/a/b。</p></li></ul><h3 id="总结：use是中间件，可以路由以path开头的所有请求，但是all是具体的路由，无法路由下级地址的请求。"><a href="#总结：use是中间件，可以路由以path开头的所有请求，但是all是具体的路由，无法路由下级地址的请求。" class="headerlink" title="总结：use是中间件，可以路由以path开头的所有请求，但是all是具体的路由，无法路由下级地址的请求。"></a>总结：use是中间件，可以路由以path开头的所有请求，但是all是具体的路由，无法路由下级地址的请求。</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
